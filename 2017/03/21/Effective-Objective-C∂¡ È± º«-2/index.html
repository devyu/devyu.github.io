<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Objective-C," />










<meta name="description" content="对象、消息、runtimeObjective-C 语言中，“对象”是“基本的构造单元”，在对象之间传递数据并执行任务，这个过程叫做消息传递。为其提供相关支持的代码叫做Objective-C runtime，它提供了一些使得对象间能够传递消息的重要函数。 第6条：理解属性这一概念属性是 Objective-C 中用于封装对象的数据。在 Objective-C 语言中，很少像 C++、Java 那样在">
<meta name="keywords" content="Objective-C">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective-Objective-C读书笔记(2)">
<meta property="og:url" content="http://devyu.github.io/2017/03/21/Effective-Objective-C∂¡ È± º«-2/index.html">
<meta property="og:site_name" content="JY&#39;s Den">
<meta property="og:description" content="对象、消息、runtimeObjective-C 语言中，“对象”是“基本的构造单元”，在对象之间传递数据并执行任务，这个过程叫做消息传递。为其提供相关支持的代码叫做Objective-C runtime，它提供了一些使得对象间能够传递消息的重要函数。 第6条：理解属性这一概念属性是 Objective-C 中用于封装对象的数据。在 Objective-C 语言中，很少像 C++、Java 那样在">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://devyu.github.io/image/Effective-Objective-C-2.0-cahpter2-01.png">
<meta property="og:image" content="http://devyu.github.io/image/Effective-Objective-C-2.0-cahpter2-02.png">
<meta property="og:image" content="http://devyu.github.io/image/Effective-Objective-C-2.0-cahpter2-03.png">
<meta property="og:image" content="http://devyu.github.io/image/Effective-Objective-C-2.0-cahpter2-05.png">
<meta property="og:image" content="http://devyu.github.io/image/Effective-Objective-C-2.0-cahpter2-06.png">
<meta property="og:image" content="http://devyu.github.io/image/Effective-Objective-C-2.0-cahpter2-07.png">
<meta property="og:image" content="http://devyu.github.io/image/Effective-Objective-C-2.0-cahpter2-08.png">
<meta property="og:image" content="http://devyu.github.io/image/Effective-Objective-C-2.0-cahpter2-04.png">
<meta property="og:updated_time" content="2017-08-12T02:21:50.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Effective-Objective-C读书笔记(2)">
<meta name="twitter:description" content="对象、消息、runtimeObjective-C 语言中，“对象”是“基本的构造单元”，在对象之间传递数据并执行任务，这个过程叫做消息传递。为其提供相关支持的代码叫做Objective-C runtime，它提供了一些使得对象间能够传递消息的重要函数。 第6条：理解属性这一概念属性是 Objective-C 中用于封装对象的数据。在 Objective-C 语言中，很少像 C++、Java 那样在">
<meta name="twitter:image" content="http://devyu.github.io/image/Effective-Objective-C-2.0-cahpter2-01.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://devyu.github.io/2017/03/21/Effective-Objective-C∂¡ È± º«-2/"/>





  <title>Effective-Objective-C读书笔记(2) | JY's Den</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JY's Den</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">想了好久</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://devyu.github.io/2017/03/21/Effective-Objective-C∂¡ È± º«-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JY's Den">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Effective-Objective-C读书笔记(2)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-21T22:27:15+08:00">
                2017-03-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/21/Effective-Objective-C∂¡ È± º«-2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/03/21/Effective-Objective-C∂¡ È± º«-2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="对象、消息、runtime"><a href="#对象、消息、runtime" class="headerlink" title="对象、消息、runtime"></a>对象、消息、runtime</h3><p>Objective-C 语言中，“对象”是“基本的构造单元”，在对象之间传递数据并执行任务，这个过程叫做<code>消息传递</code>。为其提供相关支持的代码叫做<code>Objective-C runtime</code>，它提供了一些使得对象间能够传递消息的重要函数。</p>
<h4 id="第6条：理解属性这一概念"><a href="#第6条：理解属性这一概念" class="headerlink" title="第6条：理解属性这一概念"></a>第6条：理解属性这一概念</h4><p><code>属性</code>是 Objective-C 中用于封装对象的数据。在 Objective-C 语言中，很少像 C++、Java 那样在接口内部声明实例变量，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface EOCPerson : NSObject</span><br><span class="line">@public</span><br><span class="line">  NSString *_firstName;</span><br><span class="line">  NSString *_lastName;</span><br><span class="line">@private</span><br><span class="line">  NSString *_someInternalData;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>不像 C++、Java 那样，在这里可以定义实例变量的作用域。在 Objective-C 中，这种写法的问题是：<code>对象布局在编译期间就已经固定了</code>。只要访问<code>_firstName</code>，编译器就把其替换为偏移量（这个偏移量是硬编码，表示该变量距离存放对象的内存区域的起始地址有多远）。如果在 <code>_firstName</code> 前面又多添加一个实例变量 <code>NSDate *_dateOfBirth;</code>，这样 <code>_firstName</code> 偏移量就会改变，指向 <code>_dateOfBirth</code>，偏移量硬编码于其中就会读到错误的值。此时内存的布局如图所示：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter2-01.png" alt=""></p>
<p>如果代码使用了编译期计算出来的偏移量，那么在修改类定义之后必须重新编译，否则就会出错。然而这种将实例变量声明在<code>@interface</code>接口中暴露出类的接口，更好的方式是通过<code>@property</code> 语法来实现。可以像以下代码来声明属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface EOCPerson : NSObject</span><br><span class="line">@property NSString *firstName;</span><br><span class="line">@property NSString *lastName;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>使用<code>@property</code>属性，编译器会在<code>编译期</code>自动做以下几件事情：</p>
<ul>
<li>自动合成这些属性的 getter、setter 方法，开发者并不可见这些合成方法的源代码。</li>
<li>向类中添加适当类型的实例变量，并在属性名前加<code>_</code>，作为实例变量的名字。</li>
</ul>
<p>如果你不喜欢以<code>_</code>开头的实例变量名，可以通过<code>@synthesize</code>语法来指定实例变量的名字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface EOCPerson</span><br><span class="line">@synthesize firstName = _myFirstName;</span><br><span class="line">@synthesize lastName = _myLastName;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>上面会将实例变量命名为<code>_myFirstName</code>和<code>_myLastName</code>。</p>
<p>若不想令编译器自动合成存取方法，也可以自己实现。通过使用<code>@dynamic</code>关键字，告诉编译器：<code>不要自动创建属性所用的实例变量，也不要为其创建存取方法</code>。而且，在编译期间访问属性代码时，即使编译器没有定义存取方法，也不会报错，它相信这些方法能在运行期找到。比如 Core Data 中 <code>NSManagedObject的子类</code>。</p>
<h5 id="属性特质"><a href="#属性特质" class="headerlink" title="属性特质"></a>属性特质</h5><ul>
<li>atomic：修饰属性会给属性的设置方法加同步锁，iOS 同步锁开销大，会影响性能。若自定义方法，应该遵守与属性特质相符的原子性。然而这并不能保证其线程安全，需要更深层的锁机制才行。</li>
<li>nonatomic：不使用同步锁，</li>
<li>readwrite：编译器生成对应的<code>getter</code>、<code>setter</code>方法。</li>
<li>readonly：编译器只生成<code>getter</code>方法，可以在<code>class continuation</code>中将其定义为 readwrite 属性，保持属性在外部是 readonly 的。</li>
<li>assign：只针对基本“纯量类型”（scalar type）：例如 CGFloat、NSInteger</li>
<li>strong：属性为拥有关系，设置新值时，会 retain 新值，release 旧值，然后再将新值设置设置上去。</li>
<li>weak：属性为非拥有关系，既不 retain 新值，也不 release 旧值，对象销毁的时候，属性值会清空（置 nil）</li>
<li>unsage_unretained：与 weak 相似，但是对象销毁的时候，修饰的属性并不自动清空，所以是不安全的。</li>
<li>copy：与 strong 类似，设置方法是将其 copy。用此方法保持属性的封装性。</li>
<li>getter=name：指定 getter 的方法名，例如 UISwitch 中，<code>@property (nonatomic, getter=isOn) BOOL on</code>;</li>
<li>setter=name：指定 setter 方法名，不常见。</li>
</ul>
<h4 id="第7条：在对象内部尽量直接访问实例变量"><a href="#第7条：在对象内部尽量直接访问实例变量" class="headerlink" title="第7条：在对象内部尽量直接访问实例变量"></a>第7条：在对象内部尽量直接访问实例变量</h4><ul>
<li>在对象内部读取数据时，应该直接通过实例变量来读，而写入数据，则应通过属性来写。</li>
<li>在初始化方法及 dealloc 方法中，总是应该直接通过实例变量来读写数据。</li>
<li>在使用惰性初始化时，通过属性来获取数据</li>
</ul>
<h4 id="第8条：理解”对象同等性”"><a href="#第8条：理解”对象同等性”" class="headerlink" title="第8条：理解”对象同等性”"></a>第8条：理解”对象同等性”</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSString *foo = <span class="comment">@"Badge 123";</span></span><br><span class="line"><span class="comment">NSString *bar = [NSString stringWithFormat:@</span><span class="string">"Badge %i"</span>, <span class="number">123</span>];</span><br><span class="line"><span class="keyword">BOOL</span> equalA = (foo == <span class="built_in">bar</span>); <span class="comment">// NO</span></span><br><span class="line"><span class="keyword">BOOL</span> equalB = [foo isEqual:<span class="built_in">bar</span>]; <span class="comment">// YES</span></span><br><span class="line"><span class="keyword">BOOL</span> equalC = [foo isEqualToString:<span class="built_in">bar</span>]; <span class="comment">// YES</span></span><br></pre></td></tr></table></figure>
<p>在判断对象是否相等，需要覆写 <code>isEqual</code>和 <code>isEqualToString</code> 方法：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter2-02.png" alt=""></p>
<ul>
<li>检测对象同等性，需要提供<code>isEqual</code>与<code>hash</code>方法。</li>
<li>相同的对象必须具有相同的 hash 码，而两个相同 hash 码的对象不一定相同。</li>
</ul>
<h4 id="第9条：以“类簇模式”隐藏实现细节"><a href="#第9条：以“类簇模式”隐藏实现细节" class="headerlink" title="第9条：以“类簇模式”隐藏实现细节"></a>第9条：以“类簇模式”隐藏实现细节</h4><ul>
<li>使用类簇可以把公共的接口隐藏在父类里面，比如 <code>buttonWithType:</code>方法，根据类型返回不同的 button 实例，其类型是隐藏在类簇的公共接口后面的某个内部类型。也可以称为<code>门面模式</code>。</li>
<li>系统的常用框架经常使用类簇，比如 典型的有 UIButton，collection 类等。</li>
</ul>
<h4 id="第10条：在既有类中使用关联对象存放自定义数据"><a href="#第10条：在既有类中使用关联对象存放自定义数据" class="headerlink" title="第10条：在既有类中使用关联对象存放自定义数据"></a>第10条：在既有类中使用关联对象存放自定义数据</h4><p>Objective-C 可以通过<code>关联对象</code>给某对象关联许多其他对象，这些对象通过<code>key</code>来区分，还可以指明存储策略，用来维护相应的内存管理语句。其由<code>objc_AssociationPolicy</code>的枚举所定义。可以把关联对象理解为一个 NSDictionary，拥有对应的存取值方法，与之不同的是，存取关联对象的值是个<code>不透明的指针</code>。</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter2-03.png" alt=""></p>
<ul>
<li>可以通过关联对象将两个对象连接起来。</li>
<li>定义关联对象可以指定其内存管理语句，用来模仿定义属性时所采用的<code>拥有关系</code>与<code>非拥有关系</code>。</li>
<li>关联对象之间的关系并没有正式定义，其内存管理语句是在关联的时候才定义的，使用时要小心。</li>
</ul>
<h4 id="第11条：理解-objc-msgSend-的作用"><a href="#第11条：理解-objc-msgSend-的作用" class="headerlink" title="第11条：理解 objc_msgSend 的作用"></a>第11条：理解 objc_msgSend 的作用</h4><p>在 C 语言中，大部分程序是静态绑定的。也就是说程序在编译期间就能得到运行时所调用的函数。然而当 C 程序中存在函数指针的时候，编译期就无法得知该函数的定义，直到运行时才能决定。这就是动态绑定。在 Objective-C 中就使用动态绑定机制来决定调用的方法。在底层，所有的方法都是普通的 C 函数实现，调用哪个函数都是由运行时来改变。这种特性使得 Objective-C 称为动态的语言。发送消息可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// someObject：消息的接收者</span><br><span class="line">// messageName：称为选择子（selector）</span><br><span class="line">// selector 和参数结合起来称为`消息`</span><br><span class="line">id returnValue = [someObject messageName:parameter];</span><br></pre></td></tr></table></figure>
<p>编译器看到消息后，将其转换为一条标准的 C 语言函数调用，其原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// objc_msgSend：是可变参数的函数</span><br><span class="line">// self：消息接收者</span><br><span class="line">// SEL：selector（也就是选择子）</span><br><span class="line">// 后续参数就是消息中的参数，其顺序不变</span><br><span class="line">void objc_msgSend(id self, SEL cmd, ...)</span><br></pre></td></tr></table></figure>
<p>上面的函数经过编译器转换后变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id returnValue = objc_msgSend(someObject, @selector(messageName:), paramter);</span><br></pre></td></tr></table></figure>
<p><code>objc_msgSend</code>会根据接收者与选择自的类型调用适当的方法。该方法会在接受者所属的类中搜索其<code>方法列表（list of method）</code>，如果能找到与 selector 对应的方法，就跳至其实现代码。如果找不到，就沿着继承体系继续向上寻找，等找到匹配的方法后再跳转。如果还是找不到，就执行<code>消息转发</code>操作。</p>
<p>执行消息查找需要很多步骤，所幸的是 <code>objc_msgSend</code> 会将匹配的结果缓存到<code>快速映射表（fast map）</code>当中，下次查找执行就会很快。过程看起来很耗时，但是实际上，<code>消息派发（message dispatch）</code>并不是应用程序瓶颈所在。</p>
<p>上面只是将消息调用过程，当然还有一些特殊情况：</p>
<ul>
<li><code>objc_msgSend_stret</code>：如果带发送的消息返回结构体，可交由此函数处理。（这并不是绝对的，只有 CPU 寄存器能容纳下消息返回类型是，该函数才能处理此消息。若返回值无法容纳与 CPU 寄存器中，比如返回的结构体太大，就交个另一个函数进行派发。此时，函数通过分配在栈上的某个变量来处理消息返回的结构体。）</li>
<li><code>objc_msgSend_fpret</code>：消息返回浮点数，则交个此函数处理，这是针对某些架构的 CPU 中（比如 x86）做出特殊处理，这种情况下使用 <code>objc_msgSend</code> 并不合适。</li>
<li><code>objc_msgSend_Super</code>：给父类发送消息，如 <code>[super message:parameter]</code>，另外有两个与：<code>objc_msgSend_stret</code>、<code>objc_msgSend_fpret</code>等效的函数，用于处理法给 super 的相应消息。</li>
</ul>
<p>上面提到，<code>objc_msgSend</code> 一旦找到相应函数的实现，就会进行跳转。能这样做的原因是，Objective-C 对象每个方法都可以认为是简单的 C 函数，其原型如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;return_type&gt; Class_selector(id self, SEL _cmd, ...)</span><br></pre></td></tr></table></figure>
<p>其工作原理是：每个类中都要有一张表格，其中的指针指向这种函数，selector 作为查找表格所用的 key。这里要注意：原型与 <code>objc_msgSend</code> 函数很像，这是为了利用<code>尾递归优化</code>技术，这项优化非常关键，如果不这么做，在查找函数的过程当中就会频繁的调用堆栈，插入新的栈帧，造成栈溢出。而尾递归优化可以避免这一现象。</p>
<h4 id="第12条：理解消息转发机制"><a href="#第12条：理解消息转发机制" class="headerlink" title="第12条：理解消息转发机制"></a>第12条：理解消息转发机制</h4><p>在编译期间向类发送器无法解读的消息，并不会报错，因为在运行时可以继续向类中添加方法，所以编译器此时无法确定该类中到底会不会有某个方法实现。如果某个对象收到无法解读的消息，runtime 就会触发<code>消息转发</code>机制。我们已经遇到过消息转发流程所处理的消息了，比如这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-[__NSCFNumber lowercaseString]: unrecongnized selector sent to instance 0x87</span><br><span class="line">*** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[__NSCFNumber lowercaseString]: unrecongnized selector sent to instance 0x87&apos;</span><br></pre></td></tr></table></figure>
<p>上面这段异常就是 NSObject 的 <code>doesNotRecongnizeSelector:</code> 方法所抛出的，表明 NSNumber 没有 <code>lowercaseString</code> 方法。<code>__NSCFNumber</code> 是为了实现桥接而使用的内部类。我们在编写程序的过程中，可以在消息转发的过程中设置钩子，用以执行预定的逻辑，不应该使程序崩溃。</p>
<p>消息转发分为两个阶段：</p>
<ul>
<li>1.动态方法解析（dynamic method resolution）：先问消息接收者，所属的类，看其能否动态添加方法来处理当前未知的消息。</li>
<li>2.完整消息转发（full forwarding mechanism）：此时第一阶段已经完成，无法执行动态方法解析。runtime 使用其他手段来处理消息。</li>
</ul>
<p>上面的<code>完整消息转发</code>又包括两步：</p>
<ul>
<li>a).首先，请消息接收者查看有没有其他对象能处理这条消息，若有 runtime 则执行消息转发给该对象，一切正常。反之则执行 b)</li>
<li>b).没有备援的消息接收者，则启动完整的消息转发机制，runtime 会将消息封装到 <code>NSInvocation</code> 对象中，再给消息接收者最后一次机会，令其解决当前未处理的消息。</li>
</ul>
<p>动态方法解析：</p>
<p>对象收到无法解读的消息，会调用其所属类的类方法：<code>+ (BOOL)resolveInstanceMethod:(SEL)selector</code>。该方法表示该类能否新增实例方法来处理 SEL。继续执行转发机制之前，本类有机会新增一个处理此 selector 的方法。如果未实现的方法不是实例方法而是类方法，runtime 就会调用另外一个方法 <code>resolveClassMethod:</code>。</p>
<p>备援接收者：</p>
<p>当前接收者有第二次机会处理未知的选择子，runtime 会询问能否将消息转给其他接收者来处理。该步骤通过以下处理方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 参数代表未知的 selector，若找到备援对象，将其返回，没有找到，返回 nil</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)selector</span><br></pre></td></tr></table></figure>
<p><code>注意</code>：我们无法操作经由这一步所转发的消息。若想在发送给备援接收者之前先修改消息内容，就必须通过<code>消息转发机制</code>来做。</p>
<p>完整的消息转发：</p>
<p>消息转发来到这一步，唯一能做的就是启动完整的消息转发机制。首先创建 <code>NSInvocation</code> 对象，把尚未处理的消息封装其中（包括 selector、target、参数），消息派发系统将消息派发给目标对象。此步骤调用下列方法来转发消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation</span><br></pre></td></tr></table></figure>
<p>此方法会按照继承体系来寻找，继承体系中每个类都有机会处理此调用请求，直到 NSObject。如果最后调用了 NSObject 的方法，该方法还会继而调用 <code>doesNotRecongnizeSelector:</code> 以抛出异常，表明此 selector 未被处理。</p>
<p>整个流程图如下：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter2-05.png" alt=""></p>
<h4 id="第13条：method-swizzling"><a href="#第13条：method-swizzling" class="headerlink" title="第13条：method swizzling"></a>第13条：method swizzling</h4><p>类的方法列表会把 selector 的名称映射到相关方法的实现上，这样<code>动态消息派发系统</code>就能根据此找到应该调用的方法。该方法用 <code>IMP</code> 指针来表示，其原型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id (*IMP)(id, SEL, ...)</span><br></pre></td></tr></table></figure>
<p>比如 NSString 类的部分方法表：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter2-06.png" alt=""></p>
<p>也可以把方法表中的 IMP 进行交换：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter2-07.png" alt=""></p>
<p>有以下方法的 API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 交换两个方法的实现</span><br><span class="line">void method_exchangeImplementations(Method m1, Method m2)</span><br><span class="line"></span><br><span class="line">// 获取待交换两个参数的方法</span><br><span class="line">Method class_getInstanceMethod(Class aClass, SEL aSelector)</span><br></pre></td></tr></table></figure>
<p>举个例子，当调用 <code>lowercaseString</code> 的时候，输出日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface NSString (EOCMyAdditions)</span><br><span class="line">- (NSString *)eoc_myLowercaseString;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation NSString (EOCMyAdditions)</span><br><span class="line">- (NSString *)eoc_myLowercaseString &#123;</span><br><span class="line">  // 这段代码看似会陷入递归调用的死循环，不要忘记这个方法已经与 lowercaseString 互换了，其实是调用 lowercaseString: 方法的实现</span><br><span class="line">  NSString *lowercase = [self eoc_myLowercaseString];</span><br><span class="line">  NSLog(@&quot;%@ =&gt; %@&quot;, self, lowercase);</span><br><span class="line">  return lowercase;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 调用方式</span><br><span class="line">Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));</span><br><span class="line">Method swappedMethod = class_getInstanceMethod([NSString class], @selector(eoc_myLowercaseString));</span><br><span class="line">method_exchangeImplementations(originalMethod, swappedMethod);</span><br><span class="line"></span><br><span class="line">NSString *string = @&quot;This iS a stRiNg&quot;;</span><br><span class="line">NSString *lowercaseString = [string lowercaseString]; //  This iS a stRiNg =&gt; this is a string</span><br></pre></td></tr></table></figure>
<p>交换后其方法表如下：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter2-08.png" alt=""></p>
<h4 id="第13条：理解“类对象”"><a href="#第13条：理解“类对象”" class="headerlink" title="第13条：理解“类对象”"></a>第13条：理解“类对象”</h4><p>Objective-C 中有个特殊的类型叫做 <code>id</code>，它只带任意的 Objective-C 对象类型。一般情况下，应该指名下次接收者的具体类型，这样向其发送无法解读的消息，那么编译器就会产生警告。而 <code>id</code> 类型则不然，编译器假定它能相应所有消息。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 指定具体的类型的好处是：该类实例上调用其所没有的方法时，编译器会得知此情况并发出警告。</span><br><span class="line">NSString *pointerVariable = @&quot;Some string&quot;;</span><br><span class="line">id genericTypedString = @&quot;Some string&quot;;</span><br></pre></td></tr></table></figure>
<p><code>id</code>类型被定义在运行期程序库的头文件里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/// An opaque type that represents an Objective-C class.</span><br><span class="line">typedef struct objc_class *Class;</span><br><span class="line"></span><br><span class="line">/// Represents an instance of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/// A pointer to an instance of a class.</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>
<p>由此可见，每个对象的结构体的首个成员是 Class 类的变量，该变量定义了结构体所属的类，称为 <code>is a</code> 指针，如上面的例子中对象“是一个” <code>（is a）NSString</code> 指针，所以其 <code>is a</code> 指针就指向 NSString。Class 对象在 <code>runtime.h</code> 中可以找到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">  Class isa;</span><br><span class="line">  Class super_class;</span><br><span class="line">  const char *name;</span><br><span class="line">  long version;</span><br><span class="line">  long info;</span><br><span class="line">  long instance_size;</span><br><span class="line">  struct objc_ivar_list *ivars;</span><br><span class="line">  struct objc_method_list **methodLists;</span><br><span class="line">  struct objc_cache *cache;</span><br><span class="line">  struct objc_protocol_list *protocols;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此结构体存放类的<code>元数据（metadata）</code>，其结构分析如下：</p>
<ul>
<li>isa：指向 Class 所属的类型，也就是 metaclass，用来表示类对象本身具备的元数据。“类方法”就定义在这里，因为这些方法可以理解成<code>类对象的实例方法</code>。每个类仅有一个<code>类对象</code>，而每个“类对象”仅有一个与之相关的“元类”。没错，<code>类可以</code>理解为 <code>metaclass</code> 的实例。</li>
<li>super_class：指向 Class 的父类。</li>
<li>name：类名</li>
<li>version：版本号</li>
<li>info：存放额外的信息</li>
<li>instance_size：Class 实例的大小。</li>
<li>methodLists：上面提到的方法表。</li>
<li>cache：方法缓存</li>
<li>protocols：协议表</li>
</ul>
<p>假如，有个名为 <code>SomeClass</code> 的子类从 <code>NSObject</code> 继承而来，继承结构如下图：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter2-04.png" alt=""></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Objective-C/" rel="tag"># Objective-C</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/21/Effective-Objective-C∂¡ È± º«-1/" rel="next" title="Effective Objective-C读书笔记(1)">
                <i class="fa fa-chevron-left"></i> Effective Objective-C读书笔记(1)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/21/Effective-Objective-C∂¡ È± º«-3/" rel="prev" title="Effective-Objective-C读书笔记(3)">
                Effective-Objective-C读书笔记(3) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">JY</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">48</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/devyu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象、消息、runtime"><span class="nav-number">1.</span> <span class="nav-text">对象、消息、runtime</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第6条：理解属性这一概念"><span class="nav-number">1.1.</span> <span class="nav-text">第6条：理解属性这一概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#属性特质"><span class="nav-number">1.1.1.</span> <span class="nav-text">属性特质</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第7条：在对象内部尽量直接访问实例变量"><span class="nav-number">1.2.</span> <span class="nav-text">第7条：在对象内部尽量直接访问实例变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第8条：理解”对象同等性”"><span class="nav-number">1.3.</span> <span class="nav-text">第8条：理解”对象同等性”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第9条：以“类簇模式”隐藏实现细节"><span class="nav-number">1.4.</span> <span class="nav-text">第9条：以“类簇模式”隐藏实现细节</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第10条：在既有类中使用关联对象存放自定义数据"><span class="nav-number">1.5.</span> <span class="nav-text">第10条：在既有类中使用关联对象存放自定义数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第11条：理解-objc-msgSend-的作用"><span class="nav-number">1.6.</span> <span class="nav-text">第11条：理解 objc_msgSend 的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第12条：理解消息转发机制"><span class="nav-number">1.7.</span> <span class="nav-text">第12条：理解消息转发机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第13条：method-swizzling"><span class="nav-number">1.8.</span> <span class="nav-text">第13条：method swizzling</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第13条：理解“类对象”"><span class="nav-number">1.9.</span> <span class="nav-text">第13条：理解“类对象”</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JY</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://devyu-github-io.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://devyu.github.io/2017/03/21/Effective-Objective-C∂¡ È± º«-2/';
          this.page.identifier = '2017/03/21/Effective-Objective-C∂¡ È± º«-2/';
          this.page.title = 'Effective-Objective-C读书笔记(2)';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://devyu-github-io.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
