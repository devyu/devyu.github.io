<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="JY&#39;s Den">
<meta property="og:url" content="http://devyu.github.io/page/2/index.html">
<meta property="og:site_name" content="JY&#39;s Den">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JY&#39;s Den">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://devyu.github.io/page/2/"/>





  <title>JY's Den</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JY's Den</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">想了好久</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://devyu.github.io/2017/04/08/map°¢fitter°¢reduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JY's Den">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/08/map°¢fitter°¢reduce/" itemprop="url">map、fitter、reduce、flatMap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-08T10:14:06+08:00">
                2017-04-08
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/08/map°¢fitter°¢reduce/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/04/08/map°¢fitter°¢reduce/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在 Swift 高阶使用中，map、fitter、reduce 是很常见的操作，能使代码干净整洁。在理解其概念之前，先要明白泛型的概念。</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>定义 <code>computeIntArray</code> 函数，接收一个数组，并返回其元素的2倍组成的另一个新的数组。但此函数只支持 <code>Int</code> 类型。如果换成其他类型则不适用，所以这里考虑用泛型来解决。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">computeIntArray</span><span class="params">(xs: [Int], transform: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Int</span>) -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="keyword">var</span> result: [<span class="type">Int</span>] = []</span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> xs &#123;</span><br><span class="line">    result.append(transform(x))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doubleArray</span><span class="params">(xs: [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="keyword">return</span> computeIntArray(xs: xs) &#123; x <span class="keyword">in</span> x * <span class="number">2</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doubleArray(xs: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 换成 bool，则会出现编译错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEvenArray</span><span class="params">(xs: [Int])</span></span> -&gt; [<span class="type">Bool</span>] &#123;</span><br><span class="line">  <span class="keyword">return</span> computeIntArray(xs: xs) &#123; x <span class="keyword">in</span>  x % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛型支持各种类型，进行抽象，对于任何 Element 的数组和 transform: Element -&gt; T 函数，它都会生成一个 T 类型数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;Element, T&gt;<span class="params">(xs: [Element], transform: <span class="params">(Element)</span></span></span> -&gt; <span class="type">T</span>) -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">  <span class="keyword">var</span> result: [<span class="type">T</span>] = []</span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> xs &#123;</span><br><span class="line">    result.append(transform(x))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genericComputeArray</span>&lt;T&gt;<span class="params">(xs: [Int], transform: <span class="params">(Int)</span></span></span> -&gt; <span class="type">T</span>) -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">map</span>(xs: xs, transform: transform)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">genericComputeArray(xs: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]) &#123; x <span class="keyword">in</span> x * <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><code>map</code>函数能够被数组调用，还接收一个闭包参数，将数组中的每一个元素依次作用于该闭包，并返回一个新的数组。</p>
<p>上面的例子中，将泛型函数写成全局函数固然能够完成任务，但是为了避免写入顶层函数实现。将此函数定义为 Array 的扩展更合适。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(tranform: <span class="params">(Element)</span></span></span> -&gt; <span class="type">T</span>) -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> result: [<span class="type">T</span>] = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">      result.append(tranform(x))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="built_in">map</span> &#123; x <span class="keyword">in</span> x * x &#125;</span><br></pre></td></tr></table></figure>
<h3 id="fitter"><a href="#fitter" class="headerlink" title="fitter"></a>fitter</h3><p>与 <code>map</code> 函数类似，<code>fitter</code> 函数也可以接收一个闭包作为参数，同样可以避免函数为顶层实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(includeElement: <span class="params">(Element)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; [<span class="type">Element</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> result: [<span class="type">Element</span>] = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="keyword">self</span> <span class="keyword">where</span> includeElement(x) &#123;</span><br><span class="line">      result.append(x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["HelloWorld.swift"]</span></span><br><span class="line">[<span class="string">"HelloWorld.swift"</span>, <span class="string">"HelloWorld.md"</span>].<span class="built_in">filter</span> &#123;x <span class="keyword">in</span> x.hasSuffix(<span class="string">"swift"</span>)&#125;</span><br></pre></td></tr></table></figure>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p><code>reduce</code> 函数将变量初始化为某个值，对数组中的每一项进行遍历，最后一某种方式更新结果。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">reduce</span>&lt;T&gt;<span class="params">(initial: T, combine: <span class="params">(T, Element)</span></span></span> -&gt; <span class="type">T</span>) -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = initial</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">      result = combine(result, x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：1</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="built_in">reduce</span>(initial: <span class="number">0</span>) &#123; result, x <span class="keyword">in</span> result + x &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以用运算符作为最后一个参数。这里初始化值为：1</span></span><br><span class="line"><span class="comment">// 输出：7</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="built_in">reduce</span>(initial: <span class="number">1</span>, combine: +)</span><br></pre></td></tr></table></figure>
<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p><code>flatMap</code> 与 <code>map</code> 类似，区别是若元素值不为 nil 的情况下，<code>flatMap</code> 能将可选类型转换为非可选类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="string">"123"</span>, <span class="string">""</span>, <span class="string">"4567"</span>]</span><br><span class="line"><span class="keyword">let</span> anotherArray = array.<span class="built_in">map</span> &#123; (string: <span class="type">String</span>) -&gt; <span class="type">Int</span>? <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">let</span> length = string.characters.<span class="built_in">count</span></span><br><span class="line">  <span class="keyword">guard</span> length &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> string.characters.<span class="built_in">count</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [Optional(3), nil, Optional(4)]</span></span><br><span class="line"><span class="built_in">print</span>(anotherArray)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherArray2 = array.flatMap&#123; (string: <span class="type">String</span>) -&gt; <span class="type">Int</span>? <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">let</span> length = string.characters.<span class="built_in">count</span></span><br><span class="line">  <span class="keyword">guard</span> length &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> string.characters.<span class="built_in">count</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [3, 4]</span></span><br><span class="line"><span class="built_in">print</span>(anotherArray2)</span><br></pre></td></tr></table></figure>
<h3 id="Any-与-泛型"><a href="#Any-与-泛型" class="headerlink" title="Any 与 泛型"></a>Any 与 泛型</h3><p>尽量避免使用 <code>Any</code> 类型，因为使用 <code>Any</code> 类型会避开 swift 的类型系统。比如将 <code>noOp</code> 函数返回值设为 0 会导致类型错误。此外，任何调用 <code>noOpAny</code> 的函数都不知道返回值会被转换为何种类型。而结果就是可能导致各种各样的运行时错误。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">noOp</span>&lt;T&gt;<span class="params">(x: T)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">noOpAny</span><span class="params">(x: Any)</span></span> -&gt; <span class="type">Any</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = noOp(x: <span class="number">3</span>)</span><br><span class="line"><span class="keyword">let</span> ret = noOpAny(x: <span class="string">"3"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// oOp中，我们可以清楚返回值和输入值完全一样，而 noOpAny 则不一样，返回是任意类型。甚至和原来输入值不同的类型。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">noOpWrong</span><span class="params">(x: Any)</span></span> -&gt; <span class="type">Any</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = noOpWrong(x: <span class="string">"string"</span>)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://devyu.github.io/2017/03/21/∂¡ È± º«/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JY's Den">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/21/∂¡ È± º«/" itemprop="url">读书笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-21T23:56:40+08:00">
                2017-03-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/21/∂¡ È± º«/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/03/21/∂¡ È± º«/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章合集是整理了一些读书笔记，做了一些目录索引。</p>
<hr>
<h4 id="《Effective-Objective-C-2-0》"><a href="#《Effective-Objective-C-2-0》" class="headerlink" title="《Effective Objective-C 2.0》"></a>《Effective Objective-C 2.0》</h4><p><a href="http://devyu.xyz/2017/03/21/Effective-Objective-C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-1/" target="_blank" rel="noopener">Effective Objective-C 2.0 第一章</a></p>
<p><a href="http://devyu.xyz/2017/03/21/Effective-Objective-C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2/" target="_blank" rel="noopener">Effective Objective-C 2.0 第二章</a></p>
<p><a href="http://devyu.xyz/2017/03/21/Effective-Objective-C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-3/" target="_blank" rel="noopener">Effective Objective-C 2.0 第三章</a></p>
<p><a href="http://devyu.xyz/2017/03/21/Effective-Objective-C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-4/" target="_blank" rel="noopener">Effective Objective-C 2.0 第四章</a></p>
<p><a href="http://devyu.xyz/2017/03/21/Effective-Objective-C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-5/" target="_blank" rel="noopener">Effective Objective-C 2.0 第五章</a></p>
<p><a href="http://devyu.xyz/2017/03/21/Effective-Objective-C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-6/" target="_blank" rel="noopener">Effective Objective-C 2.0 第六章</a></p>
<p><a href="http://devyu.xyz/2017/03/21/Effective-Objective-C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-7/" target="_blank" rel="noopener">Effective Objective-C 2.0 第七章</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://devyu.github.io/2017/03/21/Effective-Objective-C∂¡ È± º«-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JY's Den">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/21/Effective-Objective-C∂¡ È± º«-7/" itemprop="url">Effective-Objective-C读书笔记(7)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-21T22:29:08+08:00">
                2017-03-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/21/Effective-Objective-C∂¡ È± º«-7/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/03/21/Effective-Objective-C∂¡ È± º«-7/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="系统框架"><a href="#系统框架" class="headerlink" title="系统框架"></a>系统框架</h3><h4 id="第47条：熟悉系统框架"><a href="#第47条：熟悉系统框架" class="headerlink" title="第47条：熟悉系统框架"></a>第47条：熟悉系统框架</h4><p>Fundation、CoreFundation、CFNetwork(封装 BSD socket，抽象成易于使用的网络接口)、CoreAudio、AVFoundation、CoreData、CoreText 等。</p>
<h4 id="第48条：多用-block-枚举，少用-for-循环"><a href="#第48条：多用-block-枚举，少用-for-循环" class="headerlink" title="第48条：多用 block 枚举，少用 for 循环"></a>第48条：多用 block 枚举，少用 for 循环</h4><p>遍历 collection 可以使用 <code>for 循环</code>、<code>NSEnumerator</code>、<code>快速遍历法</code>。<code>block 枚举</code>本身通过 GCD 来并发这行遍历操作，无需另外编写代码。而其它遍历方式无法轻易实现这一点。如果已知待遍历的 collection 含有何种对象，则应该修改签名，指出对象的具体类型。</p>
<h4 id="第49条：对自定义内存管理语句-collection-使用无缝桥接"><a href="#第49条：对自定义内存管理语句-collection-使用无缝桥接" class="headerlink" title="第49条：对自定义内存管理语句 collection 使用无缝桥接"></a>第49条：对自定义内存管理语句 collection 使用无缝桥接</h4><p>使用<code>__bridge</code>进行桥接 Foundation 与 CoreFoundation 框架中的 C 怨言数据结构之间转换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *anArray = @[@1, @2, @3];</span><br><span class="line">CFArrayRef aCFArray = (__bridge CFArrayRef)(anArray);</span><br></pre></td></tr></table></figure></p>
<p>转换涉及到的内存管理：</p>
<ul>
<li><code>__bridge</code>：告诉ARC 如何处理 Objective-C 对象，ARC 仍然具备这个对象的所有权。</li>
<li><code>__bridge_retained</code>：ARC 将交出对象的所有权。</li>
<li><code>__bridge_transfer</code>：反向转换，比如将 <code>CFArrayRef</code> 转换为 <code>NSArray *</code>。并令 ARC 获得对象所有权。</li>
<li>使用 <code>CoreFoundation</code> 框架最后一定要调用与之对应的<code>CFRelease()</code>。</li>
</ul>
<h4 id="第50条：构建缓存时选用-NSCache-而非-NSDictionary"><a href="#第50条：构建缓存时选用-NSCache-而非-NSDictionary" class="headerlink" title="第50条：构建缓存时选用 NSCache 而非 NSDictionary"></a>第50条：构建缓存时选用 NSCache 而非 NSDictionary</h4><p>对比：</p>
<ul>
<li>当系统资源耗尽，可以自动删减缓存。使用NSDictionary需要自己 hook，在内存低警告的时候手动删减缓存。NSCache 是线程安全的，NSDictionary 不具备这种优势。</li>
<li>可以给 NSCache 对象设置上限，用于限制缓存中的对象总个数。</li>
<li>将 <code>NSPurgeableData</code> 对象与 <code>NSCache</code> 搭配使用，可以实现自动清除数据的功能。也就是说，当 <code>NSPurgeableData</code> 对象锁斩内存被系统所丢弃，该对象自身也可会从缓存中移除。</li>
</ul>
<h4 id="第51条：精简-initialize-与-load-的实现代码"><a href="#第51条：精简-initialize-与-load-的实现代码" class="headerlink" title="第51条：精简 initialize 与 load 的实现代码"></a>第51条：精简 initialize 与 load 的实现代码</h4><p>对于加入runtime系统中的每个类和分类，都会调用这个方法，并且只调用一次。如果分类和类里面都定义了<code>load</code>方法，会先调用类里的，在调用分类里的。<code>load</code>方法再调用前，会加载父类的<code>load</code>方法。执行该<code>load</code>方法时，系统还处于“脆弱状态”(fragile state)，根据某个指定的程序库，却无法判断出其中各个类的载入顺序。因此，在<code>load</code>方法中使用其他类是不安全的。比如说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface EOCClassB</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">  NSLog(@&quot;Loading EOCClassB&quot;);</span><br><span class="line">  // 此处代码不安全，也许 EOCClassA 方法并没有加载</span><br><span class="line">  EOCClassA *obj = [EOCClassA new];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>该类不能在里面等待锁，也不要调用可能会加锁的方法。凡是在类加载之前执行某些任务的，基本都不太对。其真正的用途是仅仅在调试程序，比如可以在分类里编写此方法，用来判断该分类是否已经正确载入系统中。</p>
<p>想要执行与类初始化有关的操作，还要覆写<code>+ (void)initialize</code>。它与<code>+ (void)load</code>方法都是由 runtime 调用的，并且只调用一次。但是有一些区别：</p>
<ul>
<li><code>initialize</code>是<code>惰性调用的</code>，也就是程序用到相关的类时，才会调用。也就是说应用程序无需将每个类的<code>initialize</code>都执行一遍，这与<code>load</code>方法不同。对于<code>load</code>，应用程序必须阻塞并等着所有类的<code>load</code>都执行完，才能继续。</li>
<li>runtime 系统在执行该方法时，是处于正常状态的。因此，此时可以安全使用并调用任意类中的任意方法。而且 runtime 系统能确保<code>initialize</code>方法在“线程安全的环境”中执行。也就是说只有执行<code>initialize</code>的那个线程可以操作类或类实例。其他线程都要先阻塞，等着<code>initialize</code>执行完。</li>
<li><code>initialize</code>与其他消息一样，如果某个类未实现它，其父类实习那了，那么就会运行父类的实现代码。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface EOCBaseClass: NSObject</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation EOCBaseClass</span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">  NSLog(@&quot;%@ initialize&quot;, self);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface EOCSubClass: NSObject</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation EOCSubClass</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>首次使用 <code>EOCSubClass</code> 时，会输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EOCBaseClass initialize</span><br><span class="line">EOCSubClass initialize</span><br></pre></td></tr></table></figure>
<p>与其他方法一样（load 除外）， initialize 也遵循常用的继承规则。所以在初始化 EOCSubClass 时，由于子类未覆写<code>initialize</code>方法，因此还要把父类的实现代码再运行一遍。鉴于此通常会这样实现 <code>initialize</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (void)initialize &#123;</span><br><span class="line">  if (self == [EOCBaseClass class]) &#123;</span><br><span class="line">    NSLog(@&quot;%@ initialize&quot;, self);  </span><br><span class="line"></span><br><span class="line">    // 初始化内部数据，不应该在这里调用其它方法。</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>再加载阶段，如果类实现了 load 方法，那么系统就会调用它。类的 load 方法比分类的要先调用。与其他方法不同，load 方法不参与覆写机制。</li>
<li>首次使用某个类，系统会向其发送 initialize 消息，此方法遵从普通对象的覆写规则，所以要在初始化方法中判断初始化的是哪个类。</li>
<li>load、initialize 方法应该实现的更精简一些，避免循环引用。</li>
<li>常量，基本类型可以在编译期定义。无法编译期设定的全局常量（Objective-C 对象），可以放在 initialize 方法里面初始化。</li>
</ul>
<h4 id="第52条：NSTimer-会保留目标对象"><a href="#第52条：NSTimer-会保留目标对象" class="headerlink" title="第52条：NSTimer 会保留目标对象"></a>第52条：NSTimer 会保留目标对象</h4><ul>
<li>NSTimer 对象会保留其目标对象，直到计数器本身失效位置，调用 <code>invalidate</code> 方法可令计时器失效。另外，一次性的计时器在触发完任务之后也会失效。</li>
<li>反复执行任务的计时器，容易产生循环引用，因为 NSTimer 保留其目标实例，目标实例变量又持有 NSTimer，导致循环引用。</li>
<li>扩充 NSTimer 的功能，通过 block 方式来打破循环引用。如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// NSTimer+EOCBlockSupport.h</span><br><span class="line">@interface NSTimer (EOCBlockSupport)</span><br><span class="line">+ (NSTimer *)eoc_scheduledTimerWithTimeInterval:(NSTimeInterval)interval</span><br><span class="line">                                          block:(void (^)())block</span><br><span class="line">                                        repeats:(BOOL)repeats;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// NSTimer+EOCBlockSupport.m</span><br><span class="line">@implementation NSTimer (EOCBlockSupport)</span><br><span class="line">+ (NSTimer *)eoc_scheduledTimerWithTimeInterval:(NSTimeInterval)interval</span><br><span class="line">                                          block:(void (^)())block</span><br><span class="line">                                        repeats:(BOOL)repeats &#123;</span><br><span class="line">  return [self scheduledTimerWithTimeInterval:interval</span><br><span class="line">                                       target:self</span><br><span class="line">                                     selector:@selector(eoc_blockInvoke:)</span><br><span class="line">                                     userInfo:[block copy]</span><br><span class="line">                                      repeats:repeats];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)eoc_blockInvoke:(NSTimer *)timer &#123;</span><br><span class="line">  void (^block)() = timer.userInfo;</span><br><span class="line">  if (block) &#123;</span><br><span class="line">    block();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// EOCClass.h</span><br><span class="line">@interface NSTimer : NSObject</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// EOCClass.m</span><br><span class="line">@implementation EOCClass &#123;</span><br><span class="line">  NSTimer *_pollTimer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)startPolling &#123;</span><br><span class="line">  // 通过 wealSelf 来避免实例变量 _pollTimer 持有 NSTimer，NSTimer 又持有 block，block 又持有 self 的三重循环引用。</span><br><span class="line">  __weak EOCClass *wealSelf = self;</span><br><span class="line">  _pollTimer = [NSTimer eoc_scheduledTimerWithTimeInterval:5.0</span><br><span class="line">                                                     block:^&#123;</span><br><span class="line">                                                       EOCClass *strongSelf = wealSelf;</span><br><span class="line">                                                       [strongSelf p_doPoll];</span><br><span class="line">                                                     &#125; repeats:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)p_doPoll &#123;&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://devyu.github.io/2017/03/21/Effective-Objective-C∂¡ È± º«-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JY's Den">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/21/Effective-Objective-C∂¡ È± º«-6/" itemprop="url">Effective-Objective-C读书笔记(6)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-21T22:27:32+08:00">
                2017-03-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/21/Effective-Objective-C∂¡ È± º«-6/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/03/21/Effective-Objective-C∂¡ È± º«-6/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><h4 id="第37条：理解-Block"><a href="#第37条：理解-Block" class="headerlink" title="第37条：理解 Block"></a>第37条：理解 Block</h4><p>block 的语法结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">return_type (^block_name)(parameters)</span><br><span class="line"></span><br><span class="line">int (^addBlock)(int a, int b) = ^(int a, int b)&#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 调用方式</span><br><span class="line">int a = addBlock(2 + 5); // 7</span><br></pre></td></tr></table></figure>
<p>如果 block 定义在 Objective-C 类的实例方法中，除了可以访问类的所有实例变量外，还可以使用 self 变量。block 总能修改实例变量，所以在声明时无需加 <code>_block</code>。不过如果通过读取或写入操作捕获了实例变量，那么也会自动把 self 所只带的实例关联在一起。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)anInstanceMethod &#123;</span><br><span class="line">  __block int additional = 5;</span><br><span class="line">  void (^someBlock)() = ^&#123;</span><br><span class="line">    // block 修改外部变量，需要使用 `__block` 修饰</span><br><span class="line">    additional = 100;</span><br><span class="line">    _anInstanceMethod = @&quot;Something&quot;;</span><br><span class="line">    NSLog(@&quot;_anInstanceMethod = %@&quot;, _anInstanceMethod);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果某个类实例正在执行 <code>anInstanceMethod</code> 方法。那么 self 变量就指向此实例。由于 block 中没有明确使用 self 变量，所以很容易忘记 self 变量被 block 捕获。直接访问实例变量和通过 <code>self-&gt;_anInstanceMethod = @&quot;Something&quot;;</code> 来访问是等效的。一定不能忘记，self 也是对象，block 在捕获它时也会将其保留，如果 self 所指代的对象同时保留了 block，这样就会导致循环引用。</p>
<p>block 的内部结构：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter6-01.png" alt=""></p>
<p>在存放 block 内存区域中，首个变量 <code>isa</code> 指针指向 <code>Class</code> 对象的指针。其余内存里含有 block 对象正常运转所需要的信息。详细解释如下：</p>
<ul>
<li><code>isa</code>：指向 <code>Class</code> 对象的指针。</li>
<li><code>invoke</code> 变量，指向 <code>block</code> 的实现代码。函数原型至少接受一个 <code>void *</code> 类型参数，此参数代表 block，<code>void *</code> 其实是一种代替函数指针的语法结构，可以将原来用标准 C 实现的代码封装成简明易用的接口。</li>
<li><code>descriptor</code>变量，指向结构体指针。每个 block 中都包含结构体，声明了 block 对象的总体大小，<code>copy</code>与<code>dispose</code>辅助函数对应的函数指针。辅助函数在拷贝及丢弃 block 对象时运行，其中还会执行一些操作。比如前者要保留捕获的对象，后者将其释放。 block 对象会所捕获的变量拷贝一份，放在 <code>descriptor</code> 变量的后面，注意，拷贝的不是对象本身，而是对象的指针变量。在执行 block 时，要通过 <code>invoke</code> 函数把内存中捕获的变量读取出来。</li>
</ul>
<p>在定义 block 的时候，都是分配在栈内存的，然而等离开相应的作用于之后，编译器有可能把分配的 block 的内存覆写掉，虽然可以编译，但是程序运行起来有时正确，有时错误。可以通过将 block 拷贝到堆上，这样 block 就变成带有引用计数的对象，后续复制就不会真正的复制，只是增加其医用计数。当引用计数为0，堆上的 block 对象，被系统回收。栈上的 block 原本就会被系统自动回收。示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void ^(block);</span><br><span class="line">if (/* condition */) &#123;</span><br><span class="line">  block = [^&#123;</span><br><span class="line">    NSLog(@&quot;Block A&quot;);</span><br><span class="line">  &#125; copy];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  block = [^&#123;</span><br><span class="line">    NSLog(@&quot;Block B&quot;);</span><br><span class="line">  &#125; copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种是<code>全局 block</code>，这种 block 不会捕捉任何状态(比如外围变量等)，整个 block 所用的内存区域，在编译期间已经确定了。因此全局 block 可以声明在全局内存里，不需要在每次调用的时候于栈中创建，全局 block 的拷贝操作是个空操作，因此这种 block 绝不可能被系统回收。这种 block 相当于单例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void (^block)() = ^ &#123;</span><br><span class="line">  NSLog(@&quot;This is a block&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于该 block 所需要的信息在编译期就能确定，就可以把它做成全局 block。使用全局 block 可以优化程序，减少复制、丢弃该 block 时执行的不必要的操作。</p>
<p>总结：</p>
<ul>
<li>block 可以分配在栈上或堆上，也可以是全局的，分配在栈上的 block 可拷贝至堆中，这样就具备引用计数了。全局的 block 对象可以用来优化程序调用。</li>
</ul>
<h4 id="第38条：为常用-block-创建-typedef"><a href="#第38条：为常用-block-创建-typedef" class="headerlink" title="第38条：为常用 block 创建 typedef"></a>第38条：为常用 block 创建 typedef</h4><p>使用 typedef 来重新定义 block 结构，可以使代码简洁易懂，此时要避免其名称与别的类型相冲突。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^EOCCompletionHandler)(NSData *data, NSError *error);</span><br><span class="line">- (void)startWithCompletionHandler:(EOCCompletionHandler)completion;</span><br></pre></td></tr></table></figure>
<h4 id="第39条：使用-handler-block-降低代码分散程度"><a href="#第39条：使用-handler-block-降低代码分散程度" class="headerlink" title="第39条：使用 handler block 降低代码分散程度"></a>第39条：使用 handler block 降低代码分散程度</h4><p>使用 handler block 来作为回调函数，通常比使用委托代理更加简洁清晰。在设计 handler 的时候，建议成功和失败的 handle 分开写，理由是避免全部逻辑写到一起，造成 block 过长。</p>
<h4 id="第40条：block-引用所属对象时不要出现循环引用"><a href="#第40条：block-引用所属对象时不要出现循环引用" class="headerlink" title="第40条：block 引用所属对象时不要出现循环引用"></a>第40条：block 引用所属对象时不要出现循环引用</h4><p>使用 block 一定要注意循环引用的问题，一定要在适当的时机解除循环引用，而不能把责任推给 API 调用者。有一个办法可以避免破坏代码的封装性，类似于 <code>TWRequest</code> 框架所做的那样，一旦调用 completion handler 之后，就没有必要继续在保留它。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)p_requestCompleted &#123;</span><br><span class="line">  if (_completionHandler) &#123;</span><br><span class="line">    _completionHandler(_downloadedData);</span><br><span class="line">  &#125;</span><br><span class="line">  self._completionHandler = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第41条：多用-GCD，少用同步锁"><a href="#第41条：多用-GCD，少用同步锁" class="headerlink" title="第41条：多用 GCD，少用同步锁"></a>第41条：多用 GCD，少用同步锁</h4><p>不要滥用 <code>@synchronized(self)</code>，会降低代码效率。可以使用 <code>NSLock</code>、或者 <code>NSRecursiveLock</code>（递归锁，线程能够多次持有该锁，而不会出现死锁现象）。在使用 <code>atomic</code> 修饰属性的时候，setter、getter 方法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)someString &#123;</span><br><span class="line">  @synchronized(self) &#123;</span><br><span class="line">    return _someString;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setSomeString:(NSString *)someString &#123;</span><br><span class="line">  @synchronized(self) &#123;</span><br><span class="line">    _someString = someString;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式能保证线程安全，但是无法保证该对象是绝对的线程安全，比如在同一线程上多次调用 getter，在两次访问期间，其他线程也可能会写入新的值。造成获取结果未必相同。</p>
<p>可以使用<code>串行同步队列</code>将读取操作与写入操作都安排在同一队列里，即可保证数据同步：<br><img src="/image/Effective-Objective-C-2.0-cahpter6-02.png" alt=""></p>
<p>然而还可以通过 <code>dispatch_barrier_async</code> 来提升同步行为的效率。在队列里面，<code>barrier block</code> 必须单独执行，不能与其他的 block 并发执行。因为串行队列当中的 block 总是按照顺序逐个来执行的。并发队列发现接下来的任务是<code>barrier block</code>，就等当前所有的并发任务处理完毕后，才单独执行 <code>barrier block</code>。等到<code>barrier block</code>执行完毕，才按照正常方式继续向下执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 在并发队列当中，读取操作是普通的 block 实现，写入则是用 `barrier block` 来实现，读取操作可以并行，但写入操作必须单步执行。</span><br><span class="line">_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">- (NSString *)someString &#123;</span><br><span class="line">  __block NSString *localSomeString;</span><br><span class="line">  dispatch_sync(localSomeString, ^&#123;</span><br><span class="line">    localSomeString = _someString;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return localSomeString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setSomeString:(NSString *)someString &#123;</span><br><span class="line">  dispatch_barrier_async(_syncQueue, ^&#123;</span><br><span class="line">    _someSting = someString;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：将同步与异步操作结合起来，可以实现普通加锁一样的机制，这样做却不会阻塞执行派发的线程。多使用<code>barrier block</code>，可以令同步行为更加高效。</p>
<h4 id="第42条：多用-GCD，少用-performSelector-系列方法"><a href="#第42条：多用-GCD，少用-performSelector-系列方法" class="headerlink" title="第42条：多用 GCD，少用 performSelector 系列方法"></a>第42条：多用 GCD，少用 performSelector 系列方法</h4><p><img src="/image/Effective-Objective-C-2.0-cahpter6-03.png" alt=""></p>
<p>总结：</p>
<ul>
<li><code>performSelector</code> 在内存管理方面会容易有疏失，因为无法确定要执行的selector具体是什么，ARC 编译器无法插入适当的内存管理方法。</li>
<li><code>performSelector</code> 系列方法处理 selector 过于局限，方法和参数个数都受到限制。</li>
<li>最好使用 GCD 来代替 <code>performSelector</code>。</li>
</ul>
<h4 id="第43条：掌握-GCD-的使用时机"><a href="#第43条：掌握-GCD-的使用时机" class="headerlink" title="第43条：掌握 GCD 的使用时机"></a>第43条：掌握 GCD 的使用时机</h4><p>在处理多线程与任务管理的问题中，可以使用 GCD、NSOperation 技术。GCD 是基于 C 的 API，NSOperation ，NSOperation 则是 Objective-C 对象。NSOperation 提供了高层的 Objective-C API ，具备实现 GCD 的大多数功能。两者需要具体问题具体分析，每种都有各自的适用场景。比如：NSOperation可以实现取消某个操作、设置操作之间的依赖关系、通过键值观察机制检测 NSOperation 对象属性、指定操作优先级等。GCD 虽然也有优先级，不过这是针对于整个队列来说，而不是针对某个块来说。</p>
<h4 id="第44条：通过-Dispatch-Group-机制，根据系统资源状况来执行任务"><a href="#第44条：通过-Dispatch-Group-机制，根据系统资源状况来执行任务" class="headerlink" title="第44条：通过 Dispatch Group 机制，根据系统资源状况来执行任务"></a>第44条：通过 Dispatch Group 机制，根据系统资源状况来执行任务</h4><p>一个任务可归为一个 dispatch group 只用，可以在并发队列里同时执行多项任务，此时 GCD 会根据资源情况来调度执行这些并发执行的任务。</p>
<h4 id="第45条：使用-dispatch-once-来执行只需要运行一次的线程安全代码"><a href="#第45条：使用-dispatch-once-来执行只需要运行一次的线程安全代码" class="headerlink" title="第45条：使用 dispatch_once 来执行只需要运行一次的线程安全代码"></a>第45条：使用 dispatch_once 来执行只需要运行一次的线程安全代码</h4><p>使用 <code>dispatch_once</code> 编写线程安全的代码。标记应该声明在 static、global 作用域中，这样只需执行一次的 block 传给 dispatch_once 函数时，传进去的标记也是相同的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">static EOCClass *sharedInstance = nil;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">  // code to be executed once</span><br><span class="line">  sharedInstance = [[self alloc] init];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="第46条：不要使用-dispatch-get-current-queue"><a href="#第46条：不要使用-dispatch-get-current-queue" class="headerlink" title="第46条：不要使用 dispatch_get_current_queue"></a>第46条：不要使用 dispatch_get_current_queue</h4><p><code>dispatch_get_current_queue</code> 函数已经废弃，只应做调试使用。由于派发队列是按照层级来组织的，所以无法单用某个队列对象来描述“当前队列”这个概念。为了解决死锁问题，可以用“队列特定数据”来替代<code>dispatch_get_current_queue</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://devyu.github.io/2017/03/21/Effective-Objective-C∂¡ È± º«-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JY's Den">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/21/Effective-Objective-C∂¡ È± º«-5/" itemprop="url">Effective-Objective-C读书笔记(5)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-21T22:27:28+08:00">
                2017-03-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/21/Effective-Objective-C∂¡ È± º«-5/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/03/21/Effective-Objective-C∂¡ È± º«-5/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="第29条：理解引用计数"><a href="#第29条：理解引用计数" class="headerlink" title="第29条：理解引用计数"></a>第29条：理解引用计数</h4><p>通过引用计数来管理内存，当对象使用 <code>new</code>、<code>alloc</code>、<code>retain</code>，创建的时候，其 <code>引用计数+1</code>。当使用<code>release</code>的时候，<code>引用计数-1</code>。当其引用计数为0的时候，对象会被释放，同时需要将指针置 nil，防止出现<code>悬垂指针</code>。</p>
<p><code>自动释放池</code>：当对象调用 <code>release</code> 会立即递减对象的引用计数，有时候可以不调用它。改为调用 <code>autorelease</code>，此方法会在稍后递减计数，通常会在下一次事件循环的时候递减。此方法可以保证对象在跨越<code>方法调用边界</code>后一定存活。使用 <code>autorelease</code> 可以延长对象生命周期。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)stringValue &#123;</span><br><span class="line">  NSString *str = [[NSString alloc] initWithFormat:@&quot;I am this: %@&quot;, self];</span><br><span class="line">  return [str autorelease];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// stringValue 返回调用者时，此对象必然存活。所以可以这样调用</span><br><span class="line">NSString *str = [self stringValue];</span><br></pre></td></tr></table></figure>
<p>由于返回的 str 对象稍后将自动释放，所以无需再执行内存管理操作。但是如果要持有该对象的话（比如要将其设置给实例变量），那就需要保留，并稍后释放：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_instanceVariable = [[self stringValue] retain];</span><br></pre></td></tr></table></figure>
<h4 id="第30条：用-ARC-简化引用计数"><a href="#第30条：用-ARC-简化引用计数" class="headerlink" title="第30条：用 ARC 简化引用计数"></a>第30条：用 ARC 简化引用计数</h4><ul>
<li>在 ARC 环境中，引用计数实际上还是要执行的，只不过引用计数现在是由 ARC 自动添加。</li>
<li>不能使用 <code>retain</code>、<code>release</code>、<code>autorelease</code>、<code>dealloc</code> 方法。</li>
<li>若方法名以 <code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code> 开头，则返回的对象归调用者所有。</li>
<li>不使用 ARC 情况下，在实现单例类的时候，因为单例不可以释放，所有我们经常个覆写 <code>release</code> 方法，将其替换为 <code>空操作</code>。</li>
<li>ARC 下会借用 Objective-C++ 中的一项特性来清理对象，回收 Objective-C++ 对象时，待回收对象会调用 C++ 对象的析构函数。编译器如果发现对象里含有 C++ 对象，就会生成 <code>.cxx_destruct</code> 的方法。在此方法中生成清理内存的代码。</li>
<li>ARC 只负责管理 Objective-C 对象内存，CoreFoundation 对象不归 ARC 管理，开发者必须适时调用 CFRetain/CFRelease。</li>
</ul>
<h4 id="第31条：在-dealloc-方法中只释放引用并解除监听"><a href="#第31条：在-dealloc-方法中只释放引用并解除监听" class="headerlink" title="第31条：在 dealloc 方法中只释放引用并解除监听"></a>第31条：在 dealloc 方法中只释放引用并解除监听</h4><ul>
<li>在 dealloc 方法中，ARC 会通过自动生成 <code>.cxx_destruct</code> 方法，并自动释放所有的 Objective-C 对象。</li>
<li>在此方法中移除通知</li>
<li>如果不使用 ARC ，那么最后还需要调用 <code>[super dealloc]</code>。ARC 会自动执行此操作。</li>
<li>如果对象持有文件描述符等资源，应该撰文写一个方法来释放此种资源。这样的类要和使用者约定：用完资源后必须调用 close 方法。</li>
<li>执行异步任务的方法不应该在 dealloc 里调用。只能在正常状态下执行的那些方法也不应该在 dealloc 里调用，因为此时对象已处在正在回收的状态了。</li>
</ul>
<h4 id="第32条：编写异常安全代码时要注意内存管理问题"><a href="#第32条：编写异常安全代码时要注意内存管理问题" class="headerlink" title="第32条：编写异常安全代码时要注意内存管理问题"></a>第32条：编写<code>异常安全代码</code>时要注意内存管理问题</h4><ul>
<li>在非 ARC 下，使用<code>@try...@catch</code>来捕获异常，当异常发生时，程序直接执行<code>@catch</code>中的语句。忽略了<code>@try</code>中的内存管理语句。最好的做法是将<code>@try</code>中的内存管理语句放在 <code>@finally</code> 当中。</li>
<li>默认情况下，ARC 不生成安全处理异常的所需要的清理代码。开启编译器<code>-fobjc-arc-exceptions</code>标志后，可以生成这种代码，不过会导致应用程序变大。降低运行效率。</li>
</ul>
<h4 id="第33条：用弱引用避免循环引用"><a href="#第33条：用弱引用避免循环引用" class="headerlink" title="第33条：用弱引用避免循环引用"></a>第33条：用弱引用避免循环引用</h4><ul>
<li>将某些引用设置为 <code>weak</code>，避免循环引用。</li>
<li>weak 引用可以自动清空，也可以不自动清空。自动清空是随着 ARC 而引入的新特性，由运行时系统来实习那。在自动清空功能的弱引用上，可以随意读取其数据，因为这种引用不会指向已经回收过的对象。</li>
</ul>
<h4 id="第34条：使用-autoreleasepool-来降低内存峰值"><a href="#第34条：使用-autoreleasepool-来降低内存峰值" class="headerlink" title="第34条：使用 autoreleasepool 来降低内存峰值"></a>第34条：使用 <code>autoreleasepool</code> 来降低内存峰值</h4><ul>
<li>当程序当中需要创建大量的临时对象（比如循环），会造成内存增长，可以考虑将临时代码放在<code>autoreleasepool</code>当中，那么在循环中自动释放的对象就会放在这个池，而不是线程的主池里面。</li>
<li><code>autoreleasepool</code>存放在栈中，对象收到 <code>autorelease</code> 消息后，系统将其放入最顶端的池里。</li>
</ul>
<h4 id="第35条：用僵尸对象调试内存管理问题"><a href="#第35条：用僵尸对象调试内存管理问题" class="headerlink" title="第35条：用僵尸对象调试内存管理问题"></a>第35条：用<code>僵尸对象</code>调试内存管理问题</h4><ul>
<li>向已经回收的对象发送消息是不安全的，因为这有时可以，有时不行。完全取决于对象所占内存有没有为其他内容所覆写，而这块内存有没有移作他用，又无法确定。此时需要开启僵尸对象进行检查。</li>
<li>系统在回收对象的时候，可以不将其真的回收，而是把它转化为僵尸对象。通过 <code>NSZombieEnabled</code> 可开启此功能。</li>
</ul>
<h4 id="第36条：不要使用-retainCount"><a href="#第36条：不要使用-retainCount" class="headerlink" title="第36条：不要使用 retainCount"></a>第36条：不要使用 retainCount</h4><ul>
<li>不要使用 retainCount 来查看对象是否还被持有，因为任何给定时间点上 <code>绝对引用计数</code> 都无法反应对象生命周期的全貌。引用计数可能处在自动释放池中，retainCount 可能不准确。</li>
<li>ARC 后，retainCount 就被废止了。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://devyu.github.io/2017/03/21/Effective-Objective-C∂¡ È± º«-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JY's Den">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/21/Effective-Objective-C∂¡ È± º«-4/" itemprop="url">Effective-Objective-C读书笔记(4)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-21T22:27:24+08:00">
                2017-03-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/21/Effective-Objective-C∂¡ È± º«-4/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/03/21/Effective-Objective-C∂¡ È± º«-4/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="协议与分类"><a href="#协议与分类" class="headerlink" title="协议与分类"></a>协议与分类</h3><h4 id="第23条：通过委托与数据源协议进行对象间通信"><a href="#第23条：通过委托与数据源协议进行对象间通信" class="headerlink" title="第23条：通过委托与数据源协议进行对象间通信"></a>第23条：通过委托与数据源协议进行对象间通信</h4><ul>
<li>如果有必要，可以实现含有<code>位段</code>的结构体，将委托对象能否响应相关协议方法这一信息缓存其中。</li>
</ul>
<h4 id="第24条：使用分类来分散代码"><a href="#第24条：使用分类来分散代码" class="headerlink" title="第24条：使用分类来分散代码"></a>第24条：使用分类来分散代码</h4><ul>
<li>使用分类将类的实现代码划分为易于管理的小块</li>
<li>将视为“私有”的方法归入叫 <code>Private</code> 的分类中，隐藏实现细节。</li>
</ul>
<h4 id="第25条：为第三方分类添加前缀"><a href="#第25条：为第三方分类添加前缀" class="headerlink" title="第25条：为第三方分类添加前缀"></a>第25条：为第三方分类添加前缀</h4><ul>
<li>向第三方类中添加分类时，应该给其名称、方法名添加专用的前缀。</li>
</ul>
<h4 id="第26条：不要在分类中添加属性"><a href="#第26条：不要在分类中添加属性" class="headerlink" title="第26条：不要在分类中添加属性"></a>第26条：不要在分类中添加属性</h4><ul>
<li>尽量不要在分类中添加属性，因为属性是为了封装数据的。而分类目的在于扩展类的功能，而非封装数据。</li>
<li>虽然这样定义，但是也可以在分类当中创建只读属性。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface NSCalendar (EOCCalandar)</span><br><span class="line">@property (nonatomic, strong, readonly) NSArray *eoc_allMonths;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h4 id="第27条：使用匿名分类-或者说称为扩展-来隐藏实现细节"><a href="#第27条：使用匿名分类-或者说称为扩展-来隐藏实现细节" class="headerlink" title="第27条：使用匿名分类(或者说称为扩展)来隐藏实现细节"></a>第27条：使用匿名分类(或者说称为扩展)来隐藏实现细节</h4><ul>
<li>通过匿名分类，把私有的方法、属性声明在匿名分类中。</li>
<li>若某属性在主接口中声明为 “readonly”，类内部又要用设置方法修改此属性，可以在匿名分类中将其扩展为 “readwrite”。</li>
</ul>
<h4 id="第28条：通过协议提供匿名对象"><a href="#第28条：通过协议提供匿名对象" class="headerlink" title="第28条：通过协议提供匿名对象"></a>第28条：通过协议提供匿名对象</h4><ul>
<li>提供协议来隐藏具体类内部的实现。</li>
<li>具体的对象类型可以淡化为遵从某协议的 <code>id</code> 类型，协议里规定了对象所应该实现的方法，可以使用匿名对象来表示。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://devyu.github.io/2017/03/21/Effective-Objective-C∂¡ È± º«-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JY's Den">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/21/Effective-Objective-C∂¡ È± º«-3/" itemprop="url">Effective-Objective-C读书笔记(3)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-21T22:27:20+08:00">
                2017-03-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/21/Effective-Objective-C∂¡ È± º«-3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/03/21/Effective-Objective-C∂¡ È± º«-3/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="接口与-API-设计"><a href="#接口与-API-设计" class="headerlink" title="接口与 API 设计"></a>接口与 API 设计</h3><h4 id="第15条：用前缀避免命名空间冲突"><a href="#第15条：用前缀避免命名空间冲突" class="headerlink" title="第15条：用前缀避免命名空间冲突"></a>第15条：用前缀避免命名空间冲突</h4><p>选择你的公司、应用程序或二者皆有关联的名称作为类的前缀，并在所有的代码中均使用这一前缀。</p>
<p>程序中使用到第三方库，则应为其中的名称加上前缀。如果命名出现冲突，会出现以下错误：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">duplicate symbol _OBJC_METACLASS_<span class="variable">$_</span>**<span class="number">*C</span>lass <span class="keyword">in</span>:</span><br><span class="line"><span class="built_in">..</span>.</span><br><span class="line"><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure></p>
<h4 id="第16条：提供“指定初始化方法”"><a href="#第16条：提供“指定初始化方法”" class="headerlink" title="第16条：提供“指定初始化方法”"></a>第16条：提供“指定初始化方法”</h4><p>在类当中提供一个指定初始化方法，并与文档里面说明，其他初始化方法均应该调用此方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// JYRectangle.h</span><br><span class="line">@interface JYRectangle : NSObject&lt;NSCoding&gt;</span><br><span class="line">@property (nonatomic, assign, readonly) float width;</span><br><span class="line">@property (nonatomic, assign, readonly) float height;</span><br><span class="line"></span><br><span class="line">- (id)initWithWidth:(float)width</span><br><span class="line">          andHeight:(float)height;</span><br><span class="line">- (void)methodMustBeOverride;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// JYRectangle.m</span><br><span class="line">@implementation JYRectangle</span><br><span class="line">- (id)initWithWidth:(float)width andHeight:(float)height &#123;</span><br><span class="line">  if (self = [super init]) &#123;</span><br><span class="line">    _width = width;</span><br><span class="line">    _height = height;</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">  return [self initWithWidth:5.0 andHeight:5.0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123;</span><br><span class="line">  if (self = [super init]) &#123;</span><br><span class="line">    _width = [aDecoder decodeFloatForKey:@&quot;width&quot;];</span><br><span class="line">    _height = [aDecoder decodeFloatForKey:@&quot;height&quot;];</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)encodeWithCoder:(NSCoder *)aCoder &#123;</span><br><span class="line">  [aCoder encodeFloat:_width forKey:@&quot;width&quot;];</span><br><span class="line">  [aCoder encodeFloat:_height forKey:@&quot;height&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)methodMustBeOverride &#123;</span><br><span class="line">  @throw [NSException exceptionWithName:NSInternalInconsistencyException</span><br><span class="line">                                 reason:@&quot;This method must be override !&quot;</span><br><span class="line">                               userInfo:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>如果子类想要提供不同的函数实现，需要覆写父类的方法。父类不提供实现的时候，在其中抛出异常，强制子类覆写此方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// JYSquare.h</span><br><span class="line">@interface JYSquare : JYRectangle</span><br><span class="line">- (id)initWithDimension:(float)dimension;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// JYSquare.m</span><br><span class="line">@implementation JYSquare</span><br><span class="line">- (id)initWithDimension:(float)dimension &#123;</span><br><span class="line">  return [super initWithWidth:dimension andHeight:dimension];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)initWithWidth:(float)width andHeight:(float)height &#123;</span><br><span class="line">  float dimension = MAX(width, height);</span><br><span class="line">  return [self initWithDimension:dimension];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123;</span><br><span class="line">  if ([super initWithCoder:aDecoder]) &#123;</span><br><span class="line">    // JYSquare&apos;s specific initializer</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)methodMustBeOverride &#123;</span><br><span class="line">  // If subclass is not override this method, will throw exception</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h4 id="第17条：实现-description-方法"><a href="#第17条：实现-description-方法" class="headerlink" title="第17条：实现 description 方法"></a>第17条：实现 description 方法</h4><p>实现 description 方法返回一个有意义的字符串，用来描述实例，也可以通过 debugDescription 方法返回更详细的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)description &#123;</span><br><span class="line">  return [NSString stringWithFormat:@&quot;&lt;%@: %p, %@&gt;&quot;,</span><br><span class="line">          [self class],</span><br><span class="line">          self,</span><br><span class="line">          @&#123;@&quot;title&quot;, _title,</span><br><span class="line">            @&quot;name&quot;, _name,&#125;</span><br><span class="line">          ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 只有在控制台使用 LLDB 的 po 命令有效</span><br><span class="line">- (NSString *)debugDescription &#123;</span><br><span class="line">  return [NSString stringWithFormat:@&quot;&lt;%@: %p, %@&gt;&quot;, [self class], self, _title];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第18条：尽量使用不可变对象"><a href="#第18条：尽量使用不可变对象" class="headerlink" title="第18条：尽量使用不可变对象"></a>第18条：尽量使用不可变对象</h4><ul>
<li>将对外公布的属性设置为 <code>readonly</code>，在<code>匿名分类</code>中将属性重新定义为<code>readwrite</code>。即使属性被声明为<code>readonly</code>，然而在对象外部，还可以通过 KVC 技术来设置属性的值。比如<code>[someProperty setValue:@&quot;abc&quot; forKey:@&quot;someValue&quot;];</code>，KVC 会在类中查找 <code>setSomeProperty:</code> 方法，我们最好不要通过这种 hack 方式来设置属性，不然会造成莫名的问题。</li>
<li>尽量创建不可变对象。</li>
<li>不要将 collection 作为属性公开，而是应该提供相关方法，以此修改对象中的不可变对象。</li>
</ul>
<h4 id="第19条：清晰的命名"><a href="#第19条：清晰的命名" class="headerlink" title="第19条：清晰的命名"></a>第19条：清晰的命名</h4><ul>
<li>继承自类，命名应该与类保持一致，比如从 UIView 中继承的子类，其末尾的词必须是个 View。</li>
<li>方法和变量名都使用驼峰式命名。</li>
<li>保持与自己代码或集成框架代码相符。</li>
</ul>
<h4 id="第20条：为私有方法添加前缀"><a href="#第20条：为私有方法添加前缀" class="headerlink" title="第20条：为私有方法添加前缀"></a>第20条：为私有方法添加前缀</h4><ul>
<li>私有方法建议使用 <code>p_privateMethodName</code> 开头，与公共方法区分开。</li>
<li>OC 中没有办法标记私有方法，所有根据这一条命名私有方法，增强代码可读性。</li>
<li>不要单用下划线作为私有方法的前缀，这种是预留给苹果公司使用的。</li>
</ul>
<h4 id="第21条：Objective-C-中的错误类型"><a href="#第21条：Objective-C-中的错误类型" class="headerlink" title="第21条：Objective-C 中的错误类型"></a>第21条：Objective-C 中的错误类型</h4><ul>
<li>异常只有程序发生严重错误时候才能抛出，比如定义一个抽象类，子类必须覆写父类的方法，可以在父类的方法里面抛出异常。这样子类如果没有覆写父类方法，就会抛出异常。</li>
<li>其他非致命的错误，Objective-C 中所用的编程范式为：令方法返回 nil/0，或者使用 NSError。</li>
<li>收到 NSError 消息时，必须优先处理错误。</li>
</ul>
<h4 id="第21条：NSCopying-协议"><a href="#第21条：NSCopying-协议" class="headerlink" title="第21条：NSCopying 协议"></a>第21条：NSCopying 协议</h4><p>自己的类想要支持 copy 操作，必须要实现 <code>NSCopying</code> 协议。该协议有以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// NSZone：以前开发程序会把内存分成不同的区，对象存在某个区里面。现在每个程序只有一个区：默认区，不用担心 zone 参数</span><br><span class="line">- (id)copyWithZone:(nullable NSZone *)zone;</span><br></pre></td></tr></table></figure>
<ul>
<li>复制对象时决定采用深拷贝韩式浅拷贝，一般情况下应该尽量执行浅拷贝。</li>
<li>自定义对象分为可变和不可变版本，需要同时实现 <code>NSCopying</code> 与 <code>NSMutableCopying</code>。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://devyu.github.io/2017/03/21/Effective-Objective-C∂¡ È± º«-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JY's Den">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/21/Effective-Objective-C∂¡ È± º«-2/" itemprop="url">Effective-Objective-C读书笔记(2)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-21T22:27:15+08:00">
                2017-03-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/21/Effective-Objective-C∂¡ È± º«-2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/03/21/Effective-Objective-C∂¡ È± º«-2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="对象、消息、runtime"><a href="#对象、消息、runtime" class="headerlink" title="对象、消息、runtime"></a>对象、消息、runtime</h3><p>Objective-C 语言中，“对象”是“基本的构造单元”，在对象之间传递数据并执行任务，这个过程叫做<code>消息传递</code>。为其提供相关支持的代码叫做<code>Objective-C runtime</code>，它提供了一些使得对象间能够传递消息的重要函数。</p>
<h4 id="第6条：理解属性这一概念"><a href="#第6条：理解属性这一概念" class="headerlink" title="第6条：理解属性这一概念"></a>第6条：理解属性这一概念</h4><p><code>属性</code>是 Objective-C 中用于封装对象的数据。在 Objective-C 语言中，很少像 C++、Java 那样在接口内部声明实例变量，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface EOCPerson : NSObject</span><br><span class="line">@public</span><br><span class="line">  NSString *_firstName;</span><br><span class="line">  NSString *_lastName;</span><br><span class="line">@private</span><br><span class="line">  NSString *_someInternalData;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>不像 C++、Java 那样，在这里可以定义实例变量的作用域。在 Objective-C 中，这种写法的问题是：<code>对象布局在编译期间就已经固定了</code>。只要访问<code>_firstName</code>，编译器就把其替换为偏移量（这个偏移量是硬编码，表示该变量距离存放对象的内存区域的起始地址有多远）。如果在 <code>_firstName</code> 前面又多添加一个实例变量 <code>NSDate *_dateOfBirth;</code>，这样 <code>_firstName</code> 偏移量就会改变，指向 <code>_dateOfBirth</code>，偏移量硬编码于其中就会读到错误的值。此时内存的布局如图所示：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter2-01.png" alt=""></p>
<p>如果代码使用了编译期计算出来的偏移量，那么在修改类定义之后必须重新编译，否则就会出错。然而这种将实例变量声明在<code>@interface</code>接口中暴露出类的接口，更好的方式是通过<code>@property</code> 语法来实现。可以像以下代码来声明属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface EOCPerson : NSObject</span><br><span class="line">@property NSString *firstName;</span><br><span class="line">@property NSString *lastName;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>使用<code>@property</code>属性，编译器会在<code>编译期</code>自动做以下几件事情：</p>
<ul>
<li>自动合成这些属性的 getter、setter 方法，开发者并不可见这些合成方法的源代码。</li>
<li>向类中添加适当类型的实例变量，并在属性名前加<code>_</code>，作为实例变量的名字。</li>
</ul>
<p>如果你不喜欢以<code>_</code>开头的实例变量名，可以通过<code>@synthesize</code>语法来指定实例变量的名字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface EOCPerson</span><br><span class="line">@synthesize firstName = _myFirstName;</span><br><span class="line">@synthesize lastName = _myLastName;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>上面会将实例变量命名为<code>_myFirstName</code>和<code>_myLastName</code>。</p>
<p>若不想令编译器自动合成存取方法，也可以自己实现。通过使用<code>@dynamic</code>关键字，告诉编译器：<code>不要自动创建属性所用的实例变量，也不要为其创建存取方法</code>。而且，在编译期间访问属性代码时，即使编译器没有定义存取方法，也不会报错，它相信这些方法能在运行期找到。比如 Core Data 中 <code>NSManagedObject的子类</code>。</p>
<h5 id="属性特质"><a href="#属性特质" class="headerlink" title="属性特质"></a>属性特质</h5><ul>
<li>atomic：修饰属性会给属性的设置方法加同步锁，iOS 同步锁开销大，会影响性能。若自定义方法，应该遵守与属性特质相符的原子性。然而这并不能保证其线程安全，需要更深层的锁机制才行。</li>
<li>nonatomic：不使用同步锁，</li>
<li>readwrite：编译器生成对应的<code>getter</code>、<code>setter</code>方法。</li>
<li>readonly：编译器只生成<code>getter</code>方法，可以在<code>class continuation</code>中将其定义为 readwrite 属性，保持属性在外部是 readonly 的。</li>
<li>assign：只针对基本“纯量类型”（scalar type）：例如 CGFloat、NSInteger</li>
<li>strong：属性为拥有关系，设置新值时，会 retain 新值，release 旧值，然后再将新值设置设置上去。</li>
<li>weak：属性为非拥有关系，既不 retain 新值，也不 release 旧值，对象销毁的时候，属性值会清空（置 nil）</li>
<li>unsage_unretained：与 weak 相似，但是对象销毁的时候，修饰的属性并不自动清空，所以是不安全的。</li>
<li>copy：与 strong 类似，设置方法是将其 copy。用此方法保持属性的封装性。</li>
<li>getter=name：指定 getter 的方法名，例如 UISwitch 中，<code>@property (nonatomic, getter=isOn) BOOL on</code>;</li>
<li>setter=name：指定 setter 方法名，不常见。</li>
</ul>
<h4 id="第7条：在对象内部尽量直接访问实例变量"><a href="#第7条：在对象内部尽量直接访问实例变量" class="headerlink" title="第7条：在对象内部尽量直接访问实例变量"></a>第7条：在对象内部尽量直接访问实例变量</h4><ul>
<li>在对象内部读取数据时，应该直接通过实例变量来读，而写入数据，则应通过属性来写。</li>
<li>在初始化方法及 dealloc 方法中，总是应该直接通过实例变量来读写数据。</li>
<li>在使用惰性初始化时，通过属性来获取数据</li>
</ul>
<h4 id="第8条：理解”对象同等性”"><a href="#第8条：理解”对象同等性”" class="headerlink" title="第8条：理解”对象同等性”"></a>第8条：理解”对象同等性”</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSString *foo = <span class="comment">@"Badge 123";</span></span><br><span class="line"><span class="comment">NSString *bar = [NSString stringWithFormat:@</span><span class="string">"Badge %i"</span>, <span class="number">123</span>];</span><br><span class="line"><span class="keyword">BOOL</span> equalA = (foo == <span class="built_in">bar</span>); <span class="comment">// NO</span></span><br><span class="line"><span class="keyword">BOOL</span> equalB = [foo isEqual:<span class="built_in">bar</span>]; <span class="comment">// YES</span></span><br><span class="line"><span class="keyword">BOOL</span> equalC = [foo isEqualToString:<span class="built_in">bar</span>]; <span class="comment">// YES</span></span><br></pre></td></tr></table></figure>
<p>在判断对象是否相等，需要覆写 <code>isEqual</code>和 <code>isEqualToString</code> 方法：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter2-02.png" alt=""></p>
<ul>
<li>检测对象同等性，需要提供<code>isEqual</code>与<code>hash</code>方法。</li>
<li>相同的对象必须具有相同的 hash 码，而两个相同 hash 码的对象不一定相同。</li>
</ul>
<h4 id="第9条：以“类簇模式”隐藏实现细节"><a href="#第9条：以“类簇模式”隐藏实现细节" class="headerlink" title="第9条：以“类簇模式”隐藏实现细节"></a>第9条：以“类簇模式”隐藏实现细节</h4><ul>
<li>使用类簇可以把公共的接口隐藏在父类里面，比如 <code>buttonWithType:</code>方法，根据类型返回不同的 button 实例，其类型是隐藏在类簇的公共接口后面的某个内部类型。也可以称为<code>门面模式</code>。</li>
<li>系统的常用框架经常使用类簇，比如 典型的有 UIButton，collection 类等。</li>
</ul>
<h4 id="第10条：在既有类中使用关联对象存放自定义数据"><a href="#第10条：在既有类中使用关联对象存放自定义数据" class="headerlink" title="第10条：在既有类中使用关联对象存放自定义数据"></a>第10条：在既有类中使用关联对象存放自定义数据</h4><p>Objective-C 可以通过<code>关联对象</code>给某对象关联许多其他对象，这些对象通过<code>key</code>来区分，还可以指明存储策略，用来维护相应的内存管理语句。其由<code>objc_AssociationPolicy</code>的枚举所定义。可以把关联对象理解为一个 NSDictionary，拥有对应的存取值方法，与之不同的是，存取关联对象的值是个<code>不透明的指针</code>。</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter2-03.png" alt=""></p>
<ul>
<li>可以通过关联对象将两个对象连接起来。</li>
<li>定义关联对象可以指定其内存管理语句，用来模仿定义属性时所采用的<code>拥有关系</code>与<code>非拥有关系</code>。</li>
<li>关联对象之间的关系并没有正式定义，其内存管理语句是在关联的时候才定义的，使用时要小心。</li>
</ul>
<h4 id="第11条：理解-objc-msgSend-的作用"><a href="#第11条：理解-objc-msgSend-的作用" class="headerlink" title="第11条：理解 objc_msgSend 的作用"></a>第11条：理解 objc_msgSend 的作用</h4><p>在 C 语言中，大部分程序是静态绑定的。也就是说程序在编译期间就能得到运行时所调用的函数。然而当 C 程序中存在函数指针的时候，编译期就无法得知该函数的定义，直到运行时才能决定。这就是动态绑定。在 Objective-C 中就使用动态绑定机制来决定调用的方法。在底层，所有的方法都是普通的 C 函数实现，调用哪个函数都是由运行时来改变。这种特性使得 Objective-C 称为动态的语言。发送消息可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// someObject：消息的接收者</span><br><span class="line">// messageName：称为选择子（selector）</span><br><span class="line">// selector 和参数结合起来称为`消息`</span><br><span class="line">id returnValue = [someObject messageName:parameter];</span><br></pre></td></tr></table></figure>
<p>编译器看到消息后，将其转换为一条标准的 C 语言函数调用，其原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// objc_msgSend：是可变参数的函数</span><br><span class="line">// self：消息接收者</span><br><span class="line">// SEL：selector（也就是选择子）</span><br><span class="line">// 后续参数就是消息中的参数，其顺序不变</span><br><span class="line">void objc_msgSend(id self, SEL cmd, ...)</span><br></pre></td></tr></table></figure>
<p>上面的函数经过编译器转换后变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id returnValue = objc_msgSend(someObject, @selector(messageName:), paramter);</span><br></pre></td></tr></table></figure>
<p><code>objc_msgSend</code>会根据接收者与选择自的类型调用适当的方法。该方法会在接受者所属的类中搜索其<code>方法列表（list of method）</code>，如果能找到与 selector 对应的方法，就跳至其实现代码。如果找不到，就沿着继承体系继续向上寻找，等找到匹配的方法后再跳转。如果还是找不到，就执行<code>消息转发</code>操作。</p>
<p>执行消息查找需要很多步骤，所幸的是 <code>objc_msgSend</code> 会将匹配的结果缓存到<code>快速映射表（fast map）</code>当中，下次查找执行就会很快。过程看起来很耗时，但是实际上，<code>消息派发（message dispatch）</code>并不是应用程序瓶颈所在。</p>
<p>上面只是将消息调用过程，当然还有一些特殊情况：</p>
<ul>
<li><code>objc_msgSend_stret</code>：如果带发送的消息返回结构体，可交由此函数处理。（这并不是绝对的，只有 CPU 寄存器能容纳下消息返回类型是，该函数才能处理此消息。若返回值无法容纳与 CPU 寄存器中，比如返回的结构体太大，就交个另一个函数进行派发。此时，函数通过分配在栈上的某个变量来处理消息返回的结构体。）</li>
<li><code>objc_msgSend_fpret</code>：消息返回浮点数，则交个此函数处理，这是针对某些架构的 CPU 中（比如 x86）做出特殊处理，这种情况下使用 <code>objc_msgSend</code> 并不合适。</li>
<li><code>objc_msgSend_Super</code>：给父类发送消息，如 <code>[super message:parameter]</code>，另外有两个与：<code>objc_msgSend_stret</code>、<code>objc_msgSend_fpret</code>等效的函数，用于处理法给 super 的相应消息。</li>
</ul>
<p>上面提到，<code>objc_msgSend</code> 一旦找到相应函数的实现，就会进行跳转。能这样做的原因是，Objective-C 对象每个方法都可以认为是简单的 C 函数，其原型如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;return_type&gt; Class_selector(id self, SEL _cmd, ...)</span><br></pre></td></tr></table></figure>
<p>其工作原理是：每个类中都要有一张表格，其中的指针指向这种函数，selector 作为查找表格所用的 key。这里要注意：原型与 <code>objc_msgSend</code> 函数很像，这是为了利用<code>尾递归优化</code>技术，这项优化非常关键，如果不这么做，在查找函数的过程当中就会频繁的调用堆栈，插入新的栈帧，造成栈溢出。而尾递归优化可以避免这一现象。</p>
<h4 id="第12条：理解消息转发机制"><a href="#第12条：理解消息转发机制" class="headerlink" title="第12条：理解消息转发机制"></a>第12条：理解消息转发机制</h4><p>在编译期间向类发送器无法解读的消息，并不会报错，因为在运行时可以继续向类中添加方法，所以编译器此时无法确定该类中到底会不会有某个方法实现。如果某个对象收到无法解读的消息，runtime 就会触发<code>消息转发</code>机制。我们已经遇到过消息转发流程所处理的消息了，比如这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-[__NSCFNumber lowercaseString]: unrecongnized selector sent to instance 0x87</span><br><span class="line">*** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[__NSCFNumber lowercaseString]: unrecongnized selector sent to instance 0x87&apos;</span><br></pre></td></tr></table></figure>
<p>上面这段异常就是 NSObject 的 <code>doesNotRecongnizeSelector:</code> 方法所抛出的，表明 NSNumber 没有 <code>lowercaseString</code> 方法。<code>__NSCFNumber</code> 是为了实现桥接而使用的内部类。我们在编写程序的过程中，可以在消息转发的过程中设置钩子，用以执行预定的逻辑，不应该使程序崩溃。</p>
<p>消息转发分为两个阶段：</p>
<ul>
<li>1.动态方法解析（dynamic method resolution）：先问消息接收者，所属的类，看其能否动态添加方法来处理当前未知的消息。</li>
<li>2.完整消息转发（full forwarding mechanism）：此时第一阶段已经完成，无法执行动态方法解析。runtime 使用其他手段来处理消息。</li>
</ul>
<p>上面的<code>完整消息转发</code>又包括两步：</p>
<ul>
<li>a).首先，请消息接收者查看有没有其他对象能处理这条消息，若有 runtime 则执行消息转发给该对象，一切正常。反之则执行 b)</li>
<li>b).没有备援的消息接收者，则启动完整的消息转发机制，runtime 会将消息封装到 <code>NSInvocation</code> 对象中，再给消息接收者最后一次机会，令其解决当前未处理的消息。</li>
</ul>
<p>动态方法解析：</p>
<p>对象收到无法解读的消息，会调用其所属类的类方法：<code>+ (BOOL)resolveInstanceMethod:(SEL)selector</code>。该方法表示该类能否新增实例方法来处理 SEL。继续执行转发机制之前，本类有机会新增一个处理此 selector 的方法。如果未实现的方法不是实例方法而是类方法，runtime 就会调用另外一个方法 <code>resolveClassMethod:</code>。</p>
<p>备援接收者：</p>
<p>当前接收者有第二次机会处理未知的选择子，runtime 会询问能否将消息转给其他接收者来处理。该步骤通过以下处理方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 参数代表未知的 selector，若找到备援对象，将其返回，没有找到，返回 nil</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)selector</span><br></pre></td></tr></table></figure>
<p><code>注意</code>：我们无法操作经由这一步所转发的消息。若想在发送给备援接收者之前先修改消息内容，就必须通过<code>消息转发机制</code>来做。</p>
<p>完整的消息转发：</p>
<p>消息转发来到这一步，唯一能做的就是启动完整的消息转发机制。首先创建 <code>NSInvocation</code> 对象，把尚未处理的消息封装其中（包括 selector、target、参数），消息派发系统将消息派发给目标对象。此步骤调用下列方法来转发消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation</span><br></pre></td></tr></table></figure>
<p>此方法会按照继承体系来寻找，继承体系中每个类都有机会处理此调用请求，直到 NSObject。如果最后调用了 NSObject 的方法，该方法还会继而调用 <code>doesNotRecongnizeSelector:</code> 以抛出异常，表明此 selector 未被处理。</p>
<p>整个流程图如下：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter2-05.png" alt=""></p>
<h4 id="第13条：method-swizzling"><a href="#第13条：method-swizzling" class="headerlink" title="第13条：method swizzling"></a>第13条：method swizzling</h4><p>类的方法列表会把 selector 的名称映射到相关方法的实现上，这样<code>动态消息派发系统</code>就能根据此找到应该调用的方法。该方法用 <code>IMP</code> 指针来表示，其原型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id (*IMP)(id, SEL, ...)</span><br></pre></td></tr></table></figure>
<p>比如 NSString 类的部分方法表：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter2-06.png" alt=""></p>
<p>也可以把方法表中的 IMP 进行交换：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter2-07.png" alt=""></p>
<p>有以下方法的 API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 交换两个方法的实现</span><br><span class="line">void method_exchangeImplementations(Method m1, Method m2)</span><br><span class="line"></span><br><span class="line">// 获取待交换两个参数的方法</span><br><span class="line">Method class_getInstanceMethod(Class aClass, SEL aSelector)</span><br></pre></td></tr></table></figure>
<p>举个例子，当调用 <code>lowercaseString</code> 的时候，输出日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface NSString (EOCMyAdditions)</span><br><span class="line">- (NSString *)eoc_myLowercaseString;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation NSString (EOCMyAdditions)</span><br><span class="line">- (NSString *)eoc_myLowercaseString &#123;</span><br><span class="line">  // 这段代码看似会陷入递归调用的死循环，不要忘记这个方法已经与 lowercaseString 互换了，其实是调用 lowercaseString: 方法的实现</span><br><span class="line">  NSString *lowercase = [self eoc_myLowercaseString];</span><br><span class="line">  NSLog(@&quot;%@ =&gt; %@&quot;, self, lowercase);</span><br><span class="line">  return lowercase;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 调用方式</span><br><span class="line">Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));</span><br><span class="line">Method swappedMethod = class_getInstanceMethod([NSString class], @selector(eoc_myLowercaseString));</span><br><span class="line">method_exchangeImplementations(originalMethod, swappedMethod);</span><br><span class="line"></span><br><span class="line">NSString *string = @&quot;This iS a stRiNg&quot;;</span><br><span class="line">NSString *lowercaseString = [string lowercaseString]; //  This iS a stRiNg =&gt; this is a string</span><br></pre></td></tr></table></figure>
<p>交换后其方法表如下：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter2-08.png" alt=""></p>
<h4 id="第13条：理解“类对象”"><a href="#第13条：理解“类对象”" class="headerlink" title="第13条：理解“类对象”"></a>第13条：理解“类对象”</h4><p>Objective-C 中有个特殊的类型叫做 <code>id</code>，它只带任意的 Objective-C 对象类型。一般情况下，应该指名下次接收者的具体类型，这样向其发送无法解读的消息，那么编译器就会产生警告。而 <code>id</code> 类型则不然，编译器假定它能相应所有消息。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 指定具体的类型的好处是：该类实例上调用其所没有的方法时，编译器会得知此情况并发出警告。</span><br><span class="line">NSString *pointerVariable = @&quot;Some string&quot;;</span><br><span class="line">id genericTypedString = @&quot;Some string&quot;;</span><br></pre></td></tr></table></figure>
<p><code>id</code>类型被定义在运行期程序库的头文件里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/// An opaque type that represents an Objective-C class.</span><br><span class="line">typedef struct objc_class *Class;</span><br><span class="line"></span><br><span class="line">/// Represents an instance of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/// A pointer to an instance of a class.</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>
<p>由此可见，每个对象的结构体的首个成员是 Class 类的变量，该变量定义了结构体所属的类，称为 <code>is a</code> 指针，如上面的例子中对象“是一个” <code>（is a）NSString</code> 指针，所以其 <code>is a</code> 指针就指向 NSString。Class 对象在 <code>runtime.h</code> 中可以找到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">  Class isa;</span><br><span class="line">  Class super_class;</span><br><span class="line">  const char *name;</span><br><span class="line">  long version;</span><br><span class="line">  long info;</span><br><span class="line">  long instance_size;</span><br><span class="line">  struct objc_ivar_list *ivars;</span><br><span class="line">  struct objc_method_list **methodLists;</span><br><span class="line">  struct objc_cache *cache;</span><br><span class="line">  struct objc_protocol_list *protocols;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此结构体存放类的<code>元数据（metadata）</code>，其结构分析如下：</p>
<ul>
<li>isa：指向 Class 所属的类型，也就是 metaclass，用来表示类对象本身具备的元数据。“类方法”就定义在这里，因为这些方法可以理解成<code>类对象的实例方法</code>。每个类仅有一个<code>类对象</code>，而每个“类对象”仅有一个与之相关的“元类”。没错，<code>类可以</code>理解为 <code>metaclass</code> 的实例。</li>
<li>super_class：指向 Class 的父类。</li>
<li>name：类名</li>
<li>version：版本号</li>
<li>info：存放额外的信息</li>
<li>instance_size：Class 实例的大小。</li>
<li>methodLists：上面提到的方法表。</li>
<li>cache：方法缓存</li>
<li>protocols：协议表</li>
</ul>
<p>假如，有个名为 <code>SomeClass</code> 的子类从 <code>NSObject</code> 继承而来，继承结构如下图：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter2-04.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://devyu.github.io/2017/03/21/Effective-Objective-C∂¡ È± º«-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JY's Den">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/21/Effective-Objective-C∂¡ È± º«-1/" itemprop="url">Effective Objective-C读书笔记(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-21T16:08:12+08:00">
                2017-03-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/21/Effective-Objective-C∂¡ È± º«-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/03/21/Effective-Objective-C∂¡ È± º«-1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="熟悉-Objective-C"><a href="#熟悉-Objective-C" class="headerlink" title="熟悉 Objective-C"></a>熟悉 Objective-C</h3><h4 id="Objective-C-中的消息"><a href="#Objective-C-中的消息" class="headerlink" title="Objective-C 中的消息"></a>Objective-C 中的消息</h4><p>Objective-C 起源于 Smalltalk，所以借鉴了 Smalltalk 的<code>消息结构(messaging structure)</code>，而非像 C++ 那样的<code>函数调用(function calling)</code>。<br><code>主要区别</code>：使用消息结构的语言，其运行时所应执行的代码由运行环境来决定。而使用函数调用的语言，由编译器决定。如果示例代码是多态的，那么在运行时就会按照<code>虚方法表(virtual table)</code>来查看到底该执行哪个函数实现。而采用消息结构的语言，不论是否是多态，总是在运行时才会查找要执行的方法。编译器不关心接收消息的对象是哪种类型。接收消息的对象问题也要在运行时处理。这个过程叫做<code>动态绑定</code>。</p>
<p>Objective-C 的工作都是由 <code>运行期组件(runtime component)</code>而非编译器来完成，<code>运行期组件</code>本质就是一种与开发者所编写代码相连接的动态库，这样只需更新<code>运行期组件</code>，就可以提升应用程序性能。而那种许多工作都在编译期完成的语言，想要获得类似的性能提升，则要重新编译应用程序代码。Objective-C 是 C 的“超集”，必须要理解 C 语言的内存模型。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *someString = @&quot;some string&quot;;</span><br><span class="line">NSString *anotherString = someString;</span><br></pre></td></tr></table></figure>
<p>对象是存储在堆内存当中，anotherString 指向了 string 变量，它们两个共享一块存储区域，并不会拷贝对象。其内存空间分配是这样的：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter1-01.png" alt=""></p>
<p>需要注意的是：分配在堆中的内存必须直接管理，而分配在栈上用于保存变量的内存则会在栈上弹出时自动清理。Objective-C 将内存管理抽象出来了，不用像 C 那样使用 <code>malloc</code>、<code>free</code> 来回收内存，Objective-C 在运行时把这部分工作抽象为一套内存管理的框架，叫做<code>引用计数</code>。</p>
<p>在 Objective-C 程序当中，遇到不含<code>*</code>的变量，它们可能使用<code>栈空间</code>。比如<code>CGRect</code>等等。</p>
<h4 id="类的头文件中尽量少引入其他头文件"><a href="#类的头文件中尽量少引入其他头文件" class="headerlink" title="类的头文件中尽量少引入其他头文件"></a>类的头文件中尽量少引入其他头文件</h4><p>更优雅的做法是使用 <code>@class ****</code> 来引入某个类，这叫做<code>向前声明(forward declaring)</code>该类。在<code>.m</code>文件中<code>import</code>该类。这样就隐藏了该类的所有接口实现。将引入头文件的时机尽量延后，只有在需要时才引入，这样就会减少类的使用者所需引入的头文件数量。减少编译时间。还可以避免两个互相import导致循环引用的问题。</p>
<p>如果某些类需要遵循某个协议，那么该协议必须要有完整的定义。且不能使用向前声明，这时候可以将该协议单独放在一个头文件当中。特例是<code>委托协议</code>就不用单独写一个头文件，协议只有与接受委托的类放在一起才有意义。这种情况下，最好能在实现文件中声明这个类实现了该委托协议，并把这段实现代码放在分类当中。这样只要在实现文件中引入包含委托协议的头文件即可，而不需将其放在公共头文件里。好处是降低依赖程度，缩短编译时间，代码清晰容易维护。</p>
<p>总结一下：优先使用<code>向前声明</code>来进行解耦，如果无法使用<code>向前声明</code>，尽量把<code>该类遵循某个协议</code>移至该类的分类当中。实在不行的话，就把协议单独放在一个头文件，然后将其引入。</p>
<h4 id="多使用字面量，少用与之等价的方法"><a href="#多使用字面量，少用与之等价的方法" class="headerlink" title="多使用字面量，少用与之等价的方法"></a>多使用字面量，少用与之等价的方法</h4><p>在使用字面量的时候，多使用字面数值，代码更加整洁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 不使用字面量</span><br><span class="line">NSNumber *someNumber = [NSNumber numberWithInt:1];</span><br><span class="line"></span><br><span class="line">// 使用字面量</span><br><span class="line">NSNumber *intNumber = @1;</span><br><span class="line">NSNumber *boolNumber = @YES;</span><br><span class="line"></span><br><span class="line">int x = 5;</span><br><span class="line">int y = 6.32f;</span><br><span class="line">NSNumber *number = @(x * y);</span><br></pre></td></tr></table></figure>
<p><code>字面量数组</code>：使用字面量数组更加直观，易于理解，并能尽可能早发现程序设计中的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id obj1 = /* ... */;</span><br><span class="line">id obj2 = /* ... */;</span><br><span class="line">id obj3 = /* ... */;</span><br><span class="line"></span><br><span class="line">NSArray *arrayA = [NSArray arrayWithObjects:obj1, obj2, obj3, nil];</span><br><span class="line">NSArray *arrayB = @[obj1, obj2, obj3];</span><br></pre></td></tr></table></figure>
<p>如果 <code>obj2</code> 为 nil，字面量语法创建的数组 <code>arrayB</code> 会崩溃，而 arrayA 虽然能创建出对象，但是只包含 <code>obj1</code>，因为<code>arrayWithObjects:</code>会依次处理各个参数，直到发现<code>nil</code>为止。使用字面量语法更加安全，更快的发现错误。</p>
<p><code>字典字面量</code>：与上面的数组类似，字典在遇到值为<code>nil</code>时抛出异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *dict1 = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;value1&quot;, @&quot;key1&quot;, @&quot;value2&quot;, @&quot;key2&quot;, nil];</span><br><span class="line">NSDictionary *dict2 = @&#123;</span><br><span class="line">                        @&quot;key1&quot; : @&quot;value1&quot;,</span><br><span class="line">                        @&quot;key2&quot; : @&quot;value2&quot;,</span><br><span class="line">                        &#125;;</span><br><span class="line"></span><br><span class="line">[dict1 objectForKey:@&quot;value1&quot;];</span><br><span class="line">NSString *key1 = dict2[@&quot;value1&quot;];</span><br></pre></td></tr></table></figure>
<p>注意上面的<code>dictionaryWithObjectsAndKeys:</code>的参数是 <code>&lt;Object&gt; : &lt;key&gt;</code> 的形式。很显然使用字面量更加简洁。</p>
<p><code>字面量语法也有局限性</code>：就是除了字符串意外，所创建出来的对象必须属于 Foundation 框架才行。如果自定义了这些类的子类，则无法使用字面量语法创建对象。当然很少有人这么做，因为 NSArray、NSDictionary 都是已定型的 “子族”，无需再改动。</p>
<p>使用字面量创建的对象都是<code>不可变</code>的，虽然多创建一个对象，但好处还是多于缺点的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *mutable = [@[@1, @2] mutableCopy];</span><br></pre></td></tr></table></figure></p>
<h4 id="多使用类型常量，少用-define-预处理指令"><a href="#多使用类型常量，少用-define-预处理指令" class="headerlink" title="多使用类型常量，少用 #define 预处理指令"></a>多使用类型常量，少用 #define 预处理指令</h4><p>不要使用<code>#define</code>预处理指定定义常量，这样定义出来的类型不含类型信息。编译器只是会在编译器根据此执行查找与替换操作。即使有人重新定义了常量值，编译器也不警告。可以利用编译器特性来定义。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController</span><br><span class="line">static const NSTimeInterval kAnimationDuration = 0.3;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>在实现文件中使用<code>static const</code>来定义”只在编译单元内可见的常量”（每个.m为一个编译单元），此类常量不在全局符号表当中，所以无需加前缀。</p>
<p>在头文件中使用<code>extern</code>来声明全局变量，这种常量出现在全局符号表当中。所以其名称应该加以区分，通常用类名作为前缀：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extern NSString *const EOCLoginManagerDidLoginNotification;</span><br><span class="line"></span><br><span class="line">NSString *const EOCLoginManagerDidLoginNotification = @&quot;EOCLoginManagerDidLoginNotification&quot;;</span><br></pre></td></tr></table></figure>
<h4 id="用枚举表示状态、选项、状态码"><a href="#用枚举表示状态、选项、状态码" class="headerlink" title="用枚举表示状态、选项、状态码"></a>用枚举表示状态、选项、状态码</h4><p>使用 enum 的时候需要注意，应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这个值起个通俗易懂的名字。</p>
<p>如果把传递给某个方法的选项表示为枚举类型，而多个选项可同时使用，那么将各个选项定义为2的幂，以便通过<code>按位或操作</code>将其组合起来。<br>在使用 <code>NS_ENUM</code> 和 <code>NS_OPTHONS</code> 宏来定义枚举类型，要指名其数据类型，这样做可以确保枚举是用开发者所选的数据类型实现出来的，而不会采用编译器所选的类型。<code>NS_ENUM</code> 、<code>NS_OPTHONS</code> 其实内部做了这样一件事情：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter1-02.png" alt=""></p>
<p>其实就是判断编译器是否支持新式枚举，编译器按 C++ 模式编译，那么<code>enum</code>定义枚举的时候，其展开方式与<code>NS_ENUM</code>相同。枚举值使用<code>按位或运算</code>来组合的时候，C++ 认为运算结果的数据类型应该是枚举的底层类型，也就是<code>NSUInteger</code>，C++ 不允许将这个底层类型进行隐式转换，其展开方式为<code>NS_OPTHONS</code>。鉴于此，凡是需要<code>按位或</code>操作来组合的枚举都应该使用<code>NS_OPTHONS</code>来定义。若是枚举不需要互相组合，则应使用<code>NS_ENUM</code>来定义。通常我们会这样使用：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter1-03.png" alt=""></p>
<p>在处理<code>switch</code>语句中，不要实现<code>default</code> 分支。在枚举值改变后，编译器就会提醒开发者：<code>switch</code>语句并未处理所有枚举。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://devyu.github.io/2017/03/17/ ”∆µH-264—πÀı∏Ò Ω/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JY's Den">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/17/ ”∆µH-264—πÀı∏Ò Ω/" itemprop="url">视频H.264压缩格式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-17T23:31:31+08:00">
                2017-03-17
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/17/ ”∆µH-264—πÀı∏Ò Ω/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/03/17/ ”∆µH-264—πÀı∏Ò Ω/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>摄像头采集到的原始数据，需要将图片进行压缩处理，而 H.264恰好保证了良好的压缩</p>
<p>压缩算法只压缩图像改变的部分（需要找到上一帧和下一帧的区别）。</p>
<p>软编码：ffmpeg编码，进行 h.264编码后进行传输。<br>h.264分为 I、P、B帧</p>
<p>RTMP\RTSP当中依然包含 h.264 数据</p>
<p>摄像头采集到的是 RGBA 数据，需要将数据进行编码为 H.264 的流（encode，这里面可以通过硬件编码或者软件编码，就变得很小，适合进行网络传输）</p>
<p>收到网络传输的 h.264 数据，需要还原成一帧一帧的图片，这个过程叫做 decode（硬件解码（VideoToolBox）、软件解码（FFMpeg））。</p>
<p>将解码后的 h.264 数据（解码之后就成为 YUV 数据），交给硬件去播放。</p>
<p>音频：采集(PCM，无损压缩格式) -&gt; 编码(压缩算法：g711(打电话)，adpcm，aac(进行网络传输)) -&gt; 解码 -&gt; 将解码 pcm 交给硬件进行播放<br>使用 AudioQueue、openAL 进行播放视频</p>
<p>OpenCL：进行并行计算、深度学习等<br>OpenGL：3D、2D 游戏</p>
<p>码率：<br>采样率：设备在1秒钟对音频或者视频的采样次数。</p>
<h4 id="H264编码原理：I-B-P"><a href="#H264编码原理：I-B-P" class="headerlink" title="H264编码原理：I/B/P"></a>H264编码原理：I/B/P</h4><p>I 帧：帧内编码帧，I 帧表示关键帧，可以理解为这一帧画面的完整保留<br>解码时使用本帧数据就可以完成。解码时 I 帧就可以完全还原图像<br>P 帧：是 I 帧的参考帧，是 I 帧后面间隔1~2秒后的参考帧，也是 B 帧的参考帧<br>B 帧：双向差别帧，需要前面的 I 帧和后面的 P 帧进行压缩</p>
<h4 id="H264-NAL-头文件解析（重要）"><a href="#H264-NAL-头文件解析（重要）" class="headerlink" title="H264 NAL 头文件解析（重要）"></a>H264 NAL 头文件解析（重要）</h4><h4 id="PCM-gt-aac-编码规则"><a href="#PCM-gt-aac-编码规则" class="headerlink" title="PCM -&gt; aac 编码规则"></a>PCM -&gt; aac 编码规则</h4><p>在实际的音频编码中，假设网络每次接收到的音频数据为1280，<br>而在编码中我们设定输入的 PCM 数据为1024，实际的输出为768<br>那么如果输入的 PCM 数据小于实际接收到的音频数据，那么下次的数据<br>就会从下一帧中开始截取对应长度的音频，凑够1024长度的数据量。来进行编码<br>参考图片：PCM编码为 aac 规则</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">JY</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">52</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/devyu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JY</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://devyu-github-io.disqus.com/count.js" async></script>
    

    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
