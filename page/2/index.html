<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="JY&#39;s Den">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="JY&#39;s Den">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JY&#39;s Den">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>JY's Den</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JY's Den</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">想了好久</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/21/Effective-Objective-C∂¡ È± º«-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JY's Den">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/21/Effective-Objective-C∂¡ È± º«-3/" itemprop="url">Effective-Objective-C读书笔记(3)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-21T22:27:20+08:00">
                2017-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="接口与-API-设计"><a href="#接口与-API-设计" class="headerlink" title="接口与 API 设计"></a>接口与 API 设计</h3><h4 id="第15条：用前缀避免命名空间冲突"><a href="#第15条：用前缀避免命名空间冲突" class="headerlink" title="第15条：用前缀避免命名空间冲突"></a>第15条：用前缀避免命名空间冲突</h4><p>选择你的公司、应用程序或二者皆有关联的名称作为类的前缀，并在所有的代码中均使用这一前缀。</p>
<p>程序中使用到第三方库，则应为其中的名称加上前缀。如果命名出现冲突，会出现以下错误：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">duplicate symbol _OBJC_METACLASS_<span class="variable">$_</span>**<span class="number">*C</span>lass <span class="keyword">in</span>:</span><br><span class="line"><span class="built_in">..</span>.</span><br><span class="line"><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure></p>
<h4 id="第16条：提供“指定初始化方法”"><a href="#第16条：提供“指定初始化方法”" class="headerlink" title="第16条：提供“指定初始化方法”"></a>第16条：提供“指定初始化方法”</h4><p>在类当中提供一个指定初始化方法，并与文档里面说明，其他初始化方法均应该调用此方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// JYRectangle.h</span><br><span class="line">@interface JYRectangle : NSObject&lt;NSCoding&gt;</span><br><span class="line">@property (nonatomic, assign, readonly) float width;</span><br><span class="line">@property (nonatomic, assign, readonly) float height;</span><br><span class="line"></span><br><span class="line">- (id)initWithWidth:(float)width</span><br><span class="line">          andHeight:(float)height;</span><br><span class="line">- (void)methodMustBeOverride;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// JYRectangle.m</span><br><span class="line">@implementation JYRectangle</span><br><span class="line">- (id)initWithWidth:(float)width andHeight:(float)height &#123;</span><br><span class="line">  if (self = [super init]) &#123;</span><br><span class="line">    _width = width;</span><br><span class="line">    _height = height;</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">  return [self initWithWidth:5.0 andHeight:5.0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123;</span><br><span class="line">  if (self = [super init]) &#123;</span><br><span class="line">    _width = [aDecoder decodeFloatForKey:@&quot;width&quot;];</span><br><span class="line">    _height = [aDecoder decodeFloatForKey:@&quot;height&quot;];</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)encodeWithCoder:(NSCoder *)aCoder &#123;</span><br><span class="line">  [aCoder encodeFloat:_width forKey:@&quot;width&quot;];</span><br><span class="line">  [aCoder encodeFloat:_height forKey:@&quot;height&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)methodMustBeOverride &#123;</span><br><span class="line">  @throw [NSException exceptionWithName:NSInternalInconsistencyException</span><br><span class="line">                                 reason:@&quot;This method must be override !&quot;</span><br><span class="line">                               userInfo:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>如果子类想要提供不同的函数实现，需要覆写父类的方法。父类不提供实现的时候，在其中抛出异常，强制子类覆写此方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// JYSquare.h</span><br><span class="line">@interface JYSquare : JYRectangle</span><br><span class="line">- (id)initWithDimension:(float)dimension;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// JYSquare.m</span><br><span class="line">@implementation JYSquare</span><br><span class="line">- (id)initWithDimension:(float)dimension &#123;</span><br><span class="line">  return [super initWithWidth:dimension andHeight:dimension];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)initWithWidth:(float)width andHeight:(float)height &#123;</span><br><span class="line">  float dimension = MAX(width, height);</span><br><span class="line">  return [self initWithDimension:dimension];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123;</span><br><span class="line">  if ([super initWithCoder:aDecoder]) &#123;</span><br><span class="line">    // JYSquare&apos;s specific initializer</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)methodMustBeOverride &#123;</span><br><span class="line">  // If subclass is not override this method, will throw exception</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h4 id="第17条：实现-description-方法"><a href="#第17条：实现-description-方法" class="headerlink" title="第17条：实现 description 方法"></a>第17条：实现 description 方法</h4><p>实现 description 方法返回一个有意义的字符串，用来描述实例，也可以通过 debugDescription 方法返回更详细的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)description &#123;</span><br><span class="line">  return [NSString stringWithFormat:@&quot;&lt;%@: %p, %@&gt;&quot;,</span><br><span class="line">          [self class],</span><br><span class="line">          self,</span><br><span class="line">          @&#123;@&quot;title&quot;, _title,</span><br><span class="line">            @&quot;name&quot;, _name,&#125;</span><br><span class="line">          ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 只有在控制台使用 LLDB 的 po 命令有效</span><br><span class="line">- (NSString *)debugDescription &#123;</span><br><span class="line">  return [NSString stringWithFormat:@&quot;&lt;%@: %p, %@&gt;&quot;, [self class], self, _title];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第18条：尽量使用不可变对象"><a href="#第18条：尽量使用不可变对象" class="headerlink" title="第18条：尽量使用不可变对象"></a>第18条：尽量使用不可变对象</h4><ul>
<li>将对外公布的属性设置为 <code>readonly</code>，在<code>匿名分类</code>中将属性重新定义为<code>readwrite</code>。即使属性被声明为<code>readonly</code>，然而在对象外部，还可以通过 KVC 技术来设置属性的值。比如<code>[someProperty setValue:@&quot;abc&quot; forKey:@&quot;someValue&quot;];</code>，KVC 会在类中查找 <code>setSomeProperty:</code> 方法，我们最好不要通过这种 hack 方式来设置属性，不然会造成莫名的问题。</li>
<li>尽量创建不可变对象。</li>
<li>不要将 collection 作为属性公开，而是应该提供相关方法，以此修改对象中的不可变对象。</li>
</ul>
<h4 id="第19条：清晰的命名"><a href="#第19条：清晰的命名" class="headerlink" title="第19条：清晰的命名"></a>第19条：清晰的命名</h4><ul>
<li>继承自类，命名应该与类保持一致，比如从 UIView 中继承的子类，其末尾的词必须是个 View。</li>
<li>方法和变量名都使用驼峰式命名。</li>
<li>保持与自己代码或集成框架代码相符。</li>
</ul>
<h4 id="第20条：为私有方法添加前缀"><a href="#第20条：为私有方法添加前缀" class="headerlink" title="第20条：为私有方法添加前缀"></a>第20条：为私有方法添加前缀</h4><ul>
<li>私有方法建议使用 <code>p_privateMethodName</code> 开头，与公共方法区分开。</li>
<li>OC 中没有办法标记私有方法，所有根据这一条命名私有方法，增强代码可读性。</li>
<li>不要单用下划线作为私有方法的前缀，这种是预留给苹果公司使用的。</li>
</ul>
<h4 id="第21条：Objective-C-中的错误类型"><a href="#第21条：Objective-C-中的错误类型" class="headerlink" title="第21条：Objective-C 中的错误类型"></a>第21条：Objective-C 中的错误类型</h4><ul>
<li>异常只有程序发生严重错误时候才能抛出，比如定义一个抽象类，子类必须覆写父类的方法，可以在父类的方法里面抛出异常。这样子类如果没有覆写父类方法，就会抛出异常。</li>
<li>其他非致命的错误，Objective-C 中所用的编程范式为：令方法返回 nil/0，或者使用 NSError。</li>
<li>收到 NSError 消息时，必须优先处理错误。</li>
</ul>
<h4 id="第21条：NSCopying-协议"><a href="#第21条：NSCopying-协议" class="headerlink" title="第21条：NSCopying 协议"></a>第21条：NSCopying 协议</h4><p>自己的类想要支持 copy 操作，必须要实现 <code>NSCopying</code> 协议。该协议有以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// NSZone：以前开发程序会把内存分成不同的区，对象存在某个区里面。现在每个程序只有一个区：默认区，不用担心 zone 参数</span><br><span class="line">- (id)copyWithZone:(nullable NSZone *)zone;</span><br></pre></td></tr></table></figure>
<ul>
<li>复制对象时决定采用深拷贝韩式浅拷贝，一般情况下应该尽量执行浅拷贝。</li>
<li>自定义对象分为可变和不可变版本，需要同时实现 <code>NSCopying</code> 与 <code>NSMutableCopying</code>。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/21/Effective-Objective-C∂¡ È± º«-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JY's Den">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/21/Effective-Objective-C∂¡ È± º«-2/" itemprop="url">Effective-Objective-C读书笔记(2)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-21T22:27:15+08:00">
                2017-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="对象、消息、runtime"><a href="#对象、消息、runtime" class="headerlink" title="对象、消息、runtime"></a>对象、消息、runtime</h3><p>Objective-C 语言中，“对象”是“基本的构造单元”，在对象之间传递数据并执行任务，这个过程叫做<code>消息传递</code>。为其提供相关支持的代码叫做<code>Objective-C runtime</code>，它提供了一些使得对象间能够传递消息的重要函数。</p>
<h4 id="第6条：理解属性这一概念"><a href="#第6条：理解属性这一概念" class="headerlink" title="第6条：理解属性这一概念"></a>第6条：理解属性这一概念</h4><p><code>属性</code>是 Objective-C 中用于封装对象的数据。在 Objective-C 语言中，很少像 C++、Java 那样在接口内部声明实例变量，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface EOCPerson : NSObject</span><br><span class="line">@public</span><br><span class="line">  NSString *_firstName;</span><br><span class="line">  NSString *_lastName;</span><br><span class="line">@private</span><br><span class="line">  NSString *_someInternalData;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>不像 C++、Java 那样，在这里可以定义实例变量的作用域。在 Objective-C 中，这种写法的问题是：<code>对象布局在编译期间就已经固定了</code>。只要访问<code>_firstName</code>，编译器就把其替换为偏移量（这个偏移量是硬编码，表示该变量距离存放对象的内存区域的起始地址有多远）。如果在 <code>_firstName</code> 前面又多添加一个实例变量 <code>NSDate *_dateOfBirth;</code>，这样 <code>_firstName</code> 偏移量就会改变，指向 <code>_dateOfBirth</code>，偏移量硬编码于其中就会读到错误的值。此时内存的布局如图所示：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter2-01.png" alt=""></p>
<p>如果代码使用了编译期计算出来的偏移量，那么在修改类定义之后必须重新编译，否则就会出错。然而这种将实例变量声明在<code>@interface</code>接口中暴露出类的接口，更好的方式是通过<code>@property</code> 语法来实现。可以像以下代码来声明属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface EOCPerson : NSObject</span><br><span class="line">@property NSString *firstName;</span><br><span class="line">@property NSString *lastName;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>使用<code>@property</code>属性，编译器会在<code>编译期</code>自动做以下几件事情：</p>
<ul>
<li>自动合成这些属性的 getter、setter 方法，开发者并不可见这些合成方法的源代码。</li>
<li>向类中添加适当类型的实例变量，并在属性名前加<code>_</code>，作为实例变量的名字。</li>
</ul>
<p>如果你不喜欢以<code>_</code>开头的实例变量名，可以通过<code>@synthesize</code>语法来指定实例变量的名字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface EOCPerson</span><br><span class="line">@synthesize firstName = _myFirstName;</span><br><span class="line">@synthesize lastName = _myLastName;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>上面会将实例变量命名为<code>_myFirstName</code>和<code>_myLastName</code>。</p>
<p>若不想令编译器自动合成存取方法，也可以自己实现。通过使用<code>@dynamic</code>关键字，告诉编译器：<code>不要自动创建属性所用的实例变量，也不要为其创建存取方法</code>。而且，在编译期间访问属性代码时，即使编译器没有定义存取方法，也不会报错，它相信这些方法能在运行期找到。比如 Core Data 中 <code>NSManagedObject的子类</code>。</p>
<h5 id="属性特质"><a href="#属性特质" class="headerlink" title="属性特质"></a>属性特质</h5><ul>
<li>atomic：修饰属性会给属性的设置方法加同步锁，iOS 同步锁开销大，会影响性能。若自定义方法，应该遵守与属性特质相符的原子性。然而这并不能保证其线程安全，需要更深层的锁机制才行。</li>
<li>nonatomic：不使用同步锁，</li>
<li>readwrite：编译器生成对应的<code>getter</code>、<code>setter</code>方法。</li>
<li>readonly：编译器只生成<code>getter</code>方法，可以在<code>class continuation</code>中将其定义为 readwrite 属性，保持属性在外部是 readonly 的。</li>
<li>assign：只针对基本“纯量类型”（scalar type）：例如 CGFloat、NSInteger</li>
<li>strong：属性为拥有关系，设置新值时，会 retain 新值，release 旧值，然后再将新值设置设置上去。</li>
<li>weak：属性为非拥有关系，既不 retain 新值，也不 release 旧值，对象销毁的时候，属性值会清空（置 nil）</li>
<li>unsage_unretained：与 weak 相似，但是对象销毁的时候，修饰的属性并不自动清空，所以是不安全的。</li>
<li>copy：与 strong 类似，设置方法是将其 copy。用此方法保持属性的封装性。</li>
<li>getter=name：指定 getter 的方法名，例如 UISwitch 中，<code>@property (nonatomic, getter=isOn) BOOL on</code>;</li>
<li>setter=name：指定 setter 方法名，不常见。</li>
</ul>
<h4 id="第7条：在对象内部尽量直接访问实例变量"><a href="#第7条：在对象内部尽量直接访问实例变量" class="headerlink" title="第7条：在对象内部尽量直接访问实例变量"></a>第7条：在对象内部尽量直接访问实例变量</h4><ul>
<li>在对象内部读取数据时，应该直接通过实例变量来读，而写入数据，则应通过属性来写。</li>
<li>在初始化方法及 dealloc 方法中，总是应该直接通过实例变量来读写数据。</li>
<li>在使用惰性初始化时，通过属性来获取数据</li>
</ul>
<h4 id="第8条：理解”对象同等性”"><a href="#第8条：理解”对象同等性”" class="headerlink" title="第8条：理解”对象同等性”"></a>第8条：理解”对象同等性”</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSString *foo = <span class="comment">@"Badge 123";</span></span><br><span class="line"><span class="comment">NSString *bar = [NSString stringWithFormat:@</span><span class="string">"Badge %i"</span>, <span class="number">123</span>];</span><br><span class="line"><span class="keyword">BOOL</span> equalA = (foo == <span class="built_in">bar</span>); <span class="comment">// NO</span></span><br><span class="line"><span class="keyword">BOOL</span> equalB = [foo isEqual:<span class="built_in">bar</span>]; <span class="comment">// YES</span></span><br><span class="line"><span class="keyword">BOOL</span> equalC = [foo isEqualToString:<span class="built_in">bar</span>]; <span class="comment">// YES</span></span><br></pre></td></tr></table></figure>
<p>在判断对象是否相等，需要覆写 <code>isEqual</code>和 <code>isEqualToString</code> 方法：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter2-02.png" alt=""></p>
<ul>
<li>检测对象同等性，需要提供<code>isEqual</code>与<code>hash</code>方法。</li>
<li>相同的对象必须具有相同的 hash 码，而两个相同 hash 码的对象不一定相同。</li>
</ul>
<h4 id="第9条：以“类簇模式”隐藏实现细节"><a href="#第9条：以“类簇模式”隐藏实现细节" class="headerlink" title="第9条：以“类簇模式”隐藏实现细节"></a>第9条：以“类簇模式”隐藏实现细节</h4><ul>
<li>使用类簇可以把公共的接口隐藏在父类里面，比如 <code>buttonWithType:</code>方法，根据类型返回不同的 button 实例，其类型是隐藏在类簇的公共接口后面的某个内部类型。也可以称为<code>门面模式</code>。</li>
<li>系统的常用框架经常使用类簇，比如 典型的有 UIButton，collection 类等。</li>
</ul>
<h4 id="第10条：在既有类中使用关联对象存放自定义数据"><a href="#第10条：在既有类中使用关联对象存放自定义数据" class="headerlink" title="第10条：在既有类中使用关联对象存放自定义数据"></a>第10条：在既有类中使用关联对象存放自定义数据</h4><p>Objective-C 可以通过<code>关联对象</code>给某对象关联许多其他对象，这些对象通过<code>key</code>来区分，还可以指明存储策略，用来维护相应的内存管理语句。其由<code>objc_AssociationPolicy</code>的枚举所定义。可以把关联对象理解为一个 NSDictionary，拥有对应的存取值方法，与之不同的是，存取关联对象的值是个<code>不透明的指针</code>。</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter2-03.png" alt=""></p>
<ul>
<li>可以通过关联对象将两个对象连接起来。</li>
<li>定义关联对象可以指定其内存管理语句，用来模仿定义属性时所采用的<code>拥有关系</code>与<code>非拥有关系</code>。</li>
<li>关联对象之间的关系并没有正式定义，其内存管理语句是在关联的时候才定义的，使用时要小心。</li>
</ul>
<h4 id="第11条：理解-objc-msgSend-的作用"><a href="#第11条：理解-objc-msgSend-的作用" class="headerlink" title="第11条：理解 objc_msgSend 的作用"></a>第11条：理解 objc_msgSend 的作用</h4><p>在 C 语言中，大部分程序是静态绑定的。也就是说程序在编译期间就能得到运行时所调用的函数。然而当 C 程序中存在函数指针的时候，编译期就无法得知该函数的定义，直到运行时才能决定。这就是动态绑定。在 Objective-C 中就使用动态绑定机制来决定调用的方法。在底层，所有的方法都是普通的 C 函数实现，调用哪个函数都是由运行时来改变。这种特性使得 Objective-C 称为动态的语言。发送消息可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// someObject：消息的接收者</span><br><span class="line">// messageName：称为选择子（selector）</span><br><span class="line">// selector 和参数结合起来称为`消息`</span><br><span class="line">id returnValue = [someObject messageName:parameter];</span><br></pre></td></tr></table></figure>
<p>编译器看到消息后，将其转换为一条标准的 C 语言函数调用，其原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// objc_msgSend：是可变参数的函数</span><br><span class="line">// self：消息接收者</span><br><span class="line">// SEL：selector（也就是选择子）</span><br><span class="line">// 后续参数就是消息中的参数，其顺序不变</span><br><span class="line">void objc_msgSend(id self, SEL cmd, ...)</span><br></pre></td></tr></table></figure>
<p>上面的函数经过编译器转换后变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id returnValue = objc_msgSend(someObject, @selector(messageName:), paramter);</span><br></pre></td></tr></table></figure>
<p><code>objc_msgSend</code>会根据接收者与选择自的类型调用适当的方法。该方法会在接受者所属的类中搜索其<code>方法列表（list of method）</code>，如果能找到与 selector 对应的方法，就跳至其实现代码。如果找不到，就沿着继承体系继续向上寻找，等找到匹配的方法后再跳转。如果还是找不到，就执行<code>消息转发</code>操作。</p>
<p>执行消息查找需要很多步骤，所幸的是 <code>objc_msgSend</code> 会将匹配的结果缓存到<code>快速映射表（fast map）</code>当中，下次查找执行就会很快。过程看起来很耗时，但是实际上，<code>消息派发（message dispatch）</code>并不是应用程序瓶颈所在。</p>
<p>上面只是将消息调用过程，当然还有一些特殊情况：</p>
<ul>
<li><code>objc_msgSend_stret</code>：如果带发送的消息返回结构体，可交由此函数处理。（这并不是绝对的，只有 CPU 寄存器能容纳下消息返回类型是，该函数才能处理此消息。若返回值无法容纳与 CPU 寄存器中，比如返回的结构体太大，就交个另一个函数进行派发。此时，函数通过分配在栈上的某个变量来处理消息返回的结构体。）</li>
<li><code>objc_msgSend_fpret</code>：消息返回浮点数，则交个此函数处理，这是针对某些架构的 CPU 中（比如 x86）做出特殊处理，这种情况下使用 <code>objc_msgSend</code> 并不合适。</li>
<li><code>objc_msgSend_Super</code>：给父类发送消息，如 <code>[super message:parameter]</code>，另外有两个与：<code>objc_msgSend_stret</code>、<code>objc_msgSend_fpret</code>等效的函数，用于处理法给 super 的相应消息。</li>
</ul>
<p>上面提到，<code>objc_msgSend</code> 一旦找到相应函数的实现，就会进行跳转。能这样做的原因是，Objective-C 对象每个方法都可以认为是简单的 C 函数，其原型如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;return_type&gt; Class_selector(id self, SEL _cmd, ...)</span><br></pre></td></tr></table></figure>
<p>其工作原理是：每个类中都要有一张表格，其中的指针指向这种函数，selector 作为查找表格所用的 key。这里要注意：原型与 <code>objc_msgSend</code> 函数很像，这是为了利用<code>尾递归优化</code>技术，这项优化非常关键，如果不这么做，在查找函数的过程当中就会频繁的调用堆栈，插入新的栈帧，造成栈溢出。而尾递归优化可以避免这一现象。</p>
<h4 id="第12条：理解消息转发机制"><a href="#第12条：理解消息转发机制" class="headerlink" title="第12条：理解消息转发机制"></a>第12条：理解消息转发机制</h4><p>在编译期间向类发送器无法解读的消息，并不会报错，因为在运行时可以继续向类中添加方法，所以编译器此时无法确定该类中到底会不会有某个方法实现。如果某个对象收到无法解读的消息，runtime 就会触发<code>消息转发</code>机制。我们已经遇到过消息转发流程所处理的消息了，比如这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-[__NSCFNumber lowercaseString]: unrecongnized selector sent to instance 0x87</span><br><span class="line">*** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[__NSCFNumber lowercaseString]: unrecongnized selector sent to instance 0x87&apos;</span><br></pre></td></tr></table></figure>
<p>上面这段异常就是 NSObject 的 <code>doesNotRecongnizeSelector:</code> 方法所抛出的，表明 NSNumber 没有 <code>lowercaseString</code> 方法。<code>__NSCFNumber</code> 是为了实现桥接而使用的内部类。我们在编写程序的过程中，可以在消息转发的过程中设置钩子，用以执行预定的逻辑，不应该使程序崩溃。</p>
<p>消息转发分为两个阶段：</p>
<ul>
<li>1.动态方法解析（dynamic method resolution）：先问消息接收者，所属的类，看其能否动态添加方法来处理当前未知的消息。</li>
<li>2.完整消息转发（full forwarding mechanism）：此时第一阶段已经完成，无法执行动态方法解析。runtime 使用其他手段来处理消息。</li>
</ul>
<p>上面的<code>完整消息转发</code>又包括两步：</p>
<ul>
<li>a).首先，请消息接收者查看有没有其他对象能处理这条消息，若有 runtime 则执行消息转发给该对象，一切正常。反之则执行 b)</li>
<li>b).没有备援的消息接收者，则启动完整的消息转发机制，runtime 会将消息封装到 <code>NSInvocation</code> 对象中，再给消息接收者最后一次机会，令其解决当前未处理的消息。</li>
</ul>
<p>动态方法解析：</p>
<p>对象收到无法解读的消息，会调用其所属类的类方法：<code>+ (BOOL)resolveInstanceMethod:(SEL)selector</code>。该方法表示该类能否新增实例方法来处理 SEL。继续执行转发机制之前，本类有机会新增一个处理此 selector 的方法。如果未实现的方法不是实例方法而是类方法，runtime 就会调用另外一个方法 <code>resolveClassMethod:</code>。</p>
<p>备援接收者：</p>
<p>当前接收者有第二次机会处理未知的选择子，runtime 会询问能否将消息转给其他接收者来处理。该步骤通过以下处理方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 参数代表未知的 selector，若找到备援对象，将其返回，没有找到，返回 nil</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)selector</span><br></pre></td></tr></table></figure>
<p><code>注意</code>：我们无法操作经由这一步所转发的消息。若想在发送给备援接收者之前先修改消息内容，就必须通过<code>消息转发机制</code>来做。</p>
<p>完整的消息转发：</p>
<p>消息转发来到这一步，唯一能做的就是启动完整的消息转发机制。首先创建 <code>NSInvocation</code> 对象，把尚未处理的消息封装其中（包括 selector、target、参数），消息派发系统将消息派发给目标对象。此步骤调用下列方法来转发消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation</span><br></pre></td></tr></table></figure>
<p>此方法会按照继承体系来寻找，继承体系中每个类都有机会处理此调用请求，直到 NSObject。如果最后调用了 NSObject 的方法，该方法还会继而调用 <code>doesNotRecongnizeSelector:</code> 以抛出异常，表明此 selector 未被处理。</p>
<p>整个流程图如下：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter2-05.png" alt=""></p>
<h4 id="第13条：method-swizzling"><a href="#第13条：method-swizzling" class="headerlink" title="第13条：method swizzling"></a>第13条：method swizzling</h4><p>类的方法列表会把 selector 的名称映射到相关方法的实现上，这样<code>动态消息派发系统</code>就能根据此找到应该调用的方法。该方法用 <code>IMP</code> 指针来表示，其原型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id (*IMP)(id, SEL, ...)</span><br></pre></td></tr></table></figure>
<p>比如 NSString 类的部分方法表：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter2-06.png" alt=""></p>
<p>也可以把方法表中的 IMP 进行交换：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter2-07.png" alt=""></p>
<p>有以下方法的 API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 交换两个方法的实现</span><br><span class="line">void method_exchangeImplementations(Method m1, Method m2)</span><br><span class="line"></span><br><span class="line">// 获取待交换两个参数的方法</span><br><span class="line">Method class_getInstanceMethod(Class aClass, SEL aSelector)</span><br></pre></td></tr></table></figure>
<p>举个例子，当调用 <code>lowercaseString</code> 的时候，输出日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface NSString (EOCMyAdditions)</span><br><span class="line">- (NSString *)eoc_myLowercaseString;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation NSString (EOCMyAdditions)</span><br><span class="line">- (NSString *)eoc_myLowercaseString &#123;</span><br><span class="line">  // 这段代码看似会陷入递归调用的死循环，不要忘记这个方法已经与 lowercaseString 互换了，其实是调用 lowercaseString: 方法的实现</span><br><span class="line">  NSString *lowercase = [self eoc_myLowercaseString];</span><br><span class="line">  NSLog(@&quot;%@ =&gt; %@&quot;, self, lowercase);</span><br><span class="line">  return lowercase;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 调用方式</span><br><span class="line">Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));</span><br><span class="line">Method swappedMethod = class_getInstanceMethod([NSString class], @selector(eoc_myLowercaseString));</span><br><span class="line">method_exchangeImplementations(originalMethod, swappedMethod);</span><br><span class="line"></span><br><span class="line">NSString *string = @&quot;This iS a stRiNg&quot;;</span><br><span class="line">NSString *lowercaseString = [string lowercaseString]; //  This iS a stRiNg =&gt; this is a string</span><br></pre></td></tr></table></figure>
<p>交换后其方法表如下：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter2-08.png" alt=""></p>
<h4 id="第13条：理解“类对象”"><a href="#第13条：理解“类对象”" class="headerlink" title="第13条：理解“类对象”"></a>第13条：理解“类对象”</h4><p>Objective-C 中有个特殊的类型叫做 <code>id</code>，它只带任意的 Objective-C 对象类型。一般情况下，应该指名下次接收者的具体类型，这样向其发送无法解读的消息，那么编译器就会产生警告。而 <code>id</code> 类型则不然，编译器假定它能相应所有消息。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 指定具体的类型的好处是：该类实例上调用其所没有的方法时，编译器会得知此情况并发出警告。</span><br><span class="line">NSString *pointerVariable = @&quot;Some string&quot;;</span><br><span class="line">id genericTypedString = @&quot;Some string&quot;;</span><br></pre></td></tr></table></figure>
<p><code>id</code>类型被定义在运行期程序库的头文件里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/// An opaque type that represents an Objective-C class.</span><br><span class="line">typedef struct objc_class *Class;</span><br><span class="line"></span><br><span class="line">/// Represents an instance of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/// A pointer to an instance of a class.</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>
<p>由此可见，每个对象的结构体的首个成员是 Class 类的变量，该变量定义了结构体所属的类，称为 <code>is a</code> 指针，如上面的例子中对象“是一个” <code>（is a）NSString</code> 指针，所以其 <code>is a</code> 指针就指向 NSString。Class 对象在 <code>runtime.h</code> 中可以找到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">  Class isa;</span><br><span class="line">  Class super_class;</span><br><span class="line">  const char *name;</span><br><span class="line">  long version;</span><br><span class="line">  long info;</span><br><span class="line">  long instance_size;</span><br><span class="line">  struct objc_ivar_list *ivars;</span><br><span class="line">  struct objc_method_list **methodLists;</span><br><span class="line">  struct objc_cache *cache;</span><br><span class="line">  struct objc_protocol_list *protocols;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此结构体存放类的<code>元数据（metadata）</code>，其结构分析如下：</p>
<ul>
<li>isa：指向 Class 所属的类型，也就是 metaclass，用来表示类对象本身具备的元数据。“类方法”就定义在这里，因为这些方法可以理解成<code>类对象的实例方法</code>。每个类仅有一个<code>类对象</code>，而每个“类对象”仅有一个与之相关的“元类”。没错，<code>类可以</code>理解为 <code>metaclass</code> 的实例。</li>
<li>super_class：指向 Class 的父类。</li>
<li>name：类名</li>
<li>version：版本号</li>
<li>info：存放额外的信息</li>
<li>instance_size：Class 实例的大小。</li>
<li>methodLists：上面提到的方法表。</li>
<li>cache：方法缓存</li>
<li>protocols：协议表</li>
</ul>
<p>假如，有个名为 <code>SomeClass</code> 的子类从 <code>NSObject</code> 继承而来，继承结构如下图：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter2-04.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/21/Effective-Objective-C∂¡ È± º«-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JY's Den">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/21/Effective-Objective-C∂¡ È± º«-1/" itemprop="url">Effective Objective-C读书笔记(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-21T16:08:12+08:00">
                2017-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="熟悉-Objective-C"><a href="#熟悉-Objective-C" class="headerlink" title="熟悉 Objective-C"></a>熟悉 Objective-C</h3><h4 id="Objective-C-中的消息"><a href="#Objective-C-中的消息" class="headerlink" title="Objective-C 中的消息"></a>Objective-C 中的消息</h4><p>Objective-C 起源于 Smalltalk，所以借鉴了 Smalltalk 的<code>消息结构(messaging structure)</code>，而非像 C++ 那样的<code>函数调用(function calling)</code>。<br><code>主要区别</code>：使用消息结构的语言，其运行时所应执行的代码由运行环境来决定。而使用函数调用的语言，由编译器决定。如果示例代码是多态的，那么在运行时就会按照<code>虚方法表(virtual table)</code>来查看到底该执行哪个函数实现。而采用消息结构的语言，不论是否是多态，总是在运行时才会查找要执行的方法。编译器不关心接收消息的对象是哪种类型。接收消息的对象问题也要在运行时处理。这个过程叫做<code>动态绑定</code>。</p>
<p>Objective-C 的工作都是由 <code>运行期组件(runtime component)</code>而非编译器来完成，<code>运行期组件</code>本质就是一种与开发者所编写代码相连接的动态库，这样只需更新<code>运行期组件</code>，就可以提升应用程序性能。而那种许多工作都在编译期完成的语言，想要获得类似的性能提升，则要重新编译应用程序代码。Objective-C 是 C 的“超集”，必须要理解 C 语言的内存模型。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *someString = @&quot;some string&quot;;</span><br><span class="line">NSString *anotherString = someString;</span><br></pre></td></tr></table></figure>
<p>对象是存储在堆内存当中，anotherString 指向了 string 变量，它们两个共享一块存储区域，并不会拷贝对象。其内存空间分配是这样的：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter1-01.png" alt=""></p>
<p>需要注意的是：分配在堆中的内存必须直接管理，而分配在栈上用于保存变量的内存则会在栈上弹出时自动清理。Objective-C 将内存管理抽象出来了，不用像 C 那样使用 <code>malloc</code>、<code>free</code> 来回收内存，Objective-C 在运行时把这部分工作抽象为一套内存管理的框架，叫做<code>引用计数</code>。</p>
<p>在 Objective-C 程序当中，遇到不含<code>*</code>的变量，它们可能使用<code>栈空间</code>。比如<code>CGRect</code>等等。</p>
<h4 id="类的头文件中尽量少引入其他头文件"><a href="#类的头文件中尽量少引入其他头文件" class="headerlink" title="类的头文件中尽量少引入其他头文件"></a>类的头文件中尽量少引入其他头文件</h4><p>更优雅的做法是使用 <code>@class ****</code> 来引入某个类，这叫做<code>向前声明(forward declaring)</code>该类。在<code>.m</code>文件中<code>import</code>该类。这样就隐藏了该类的所有接口实现。将引入头文件的时机尽量延后，只有在需要时才引入，这样就会减少类的使用者所需引入的头文件数量。减少编译时间。还可以避免两个互相import导致循环引用的问题。</p>
<p>如果某些类需要遵循某个协议，那么该协议必须要有完整的定义。且不能使用向前声明，这时候可以将该协议单独放在一个头文件当中。特例是<code>委托协议</code>就不用单独写一个头文件，协议只有与接受委托的类放在一起才有意义。这种情况下，最好能在实现文件中声明这个类实现了该委托协议，并把这段实现代码放在分类当中。这样只要在实现文件中引入包含委托协议的头文件即可，而不需将其放在公共头文件里。好处是降低依赖程度，缩短编译时间，代码清晰容易维护。</p>
<p>总结一下：优先使用<code>向前声明</code>来进行解耦，如果无法使用<code>向前声明</code>，尽量把<code>该类遵循某个协议</code>移至该类的分类当中。实在不行的话，就把协议单独放在一个头文件，然后将其引入。</p>
<h4 id="多使用字面量，少用与之等价的方法"><a href="#多使用字面量，少用与之等价的方法" class="headerlink" title="多使用字面量，少用与之等价的方法"></a>多使用字面量，少用与之等价的方法</h4><p>在使用字面量的时候，多使用字面数值，代码更加整洁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 不使用字面量</span><br><span class="line">NSNumber *someNumber = [NSNumber numberWithInt:1];</span><br><span class="line"></span><br><span class="line">// 使用字面量</span><br><span class="line">NSNumber *intNumber = @1;</span><br><span class="line">NSNumber *boolNumber = @YES;</span><br><span class="line"></span><br><span class="line">int x = 5;</span><br><span class="line">int y = 6.32f;</span><br><span class="line">NSNumber *number = @(x * y);</span><br></pre></td></tr></table></figure>
<p><code>字面量数组</code>：使用字面量数组更加直观，易于理解，并能尽可能早发现程序设计中的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id obj1 = /* ... */;</span><br><span class="line">id obj2 = /* ... */;</span><br><span class="line">id obj3 = /* ... */;</span><br><span class="line"></span><br><span class="line">NSArray *arrayA = [NSArray arrayWithObjects:obj1, obj2, obj3, nil];</span><br><span class="line">NSArray *arrayB = @[obj1, obj2, obj3];</span><br></pre></td></tr></table></figure>
<p>如果 <code>obj2</code> 为 nil，字面量语法创建的数组 <code>arrayB</code> 会崩溃，而 arrayA 虽然能创建出对象，但是只包含 <code>obj1</code>，因为<code>arrayWithObjects:</code>会依次处理各个参数，直到发现<code>nil</code>为止。使用字面量语法更加安全，更快的发现错误。</p>
<p><code>字典字面量</code>：与上面的数组类似，字典在遇到值为<code>nil</code>时抛出异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *dict1 = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;value1&quot;, @&quot;key1&quot;, @&quot;value2&quot;, @&quot;key2&quot;, nil];</span><br><span class="line">NSDictionary *dict2 = @&#123;</span><br><span class="line">                        @&quot;key1&quot; : @&quot;value1&quot;,</span><br><span class="line">                        @&quot;key2&quot; : @&quot;value2&quot;,</span><br><span class="line">                        &#125;;</span><br><span class="line"></span><br><span class="line">[dict1 objectForKey:@&quot;value1&quot;];</span><br><span class="line">NSString *key1 = dict2[@&quot;value1&quot;];</span><br></pre></td></tr></table></figure>
<p>注意上面的<code>dictionaryWithObjectsAndKeys:</code>的参数是 <code>&lt;Object&gt; : &lt;key&gt;</code> 的形式。很显然使用字面量更加简洁。</p>
<p><code>字面量语法也有局限性</code>：就是除了字符串意外，所创建出来的对象必须属于 Foundation 框架才行。如果自定义了这些类的子类，则无法使用字面量语法创建对象。当然很少有人这么做，因为 NSArray、NSDictionary 都是已定型的 “子族”，无需再改动。</p>
<p>使用字面量创建的对象都是<code>不可变</code>的，虽然多创建一个对象，但好处还是多于缺点的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *mutable = [@[@1, @2] mutableCopy];</span><br></pre></td></tr></table></figure></p>
<h4 id="多使用类型常量，少用-define-预处理指令"><a href="#多使用类型常量，少用-define-预处理指令" class="headerlink" title="多使用类型常量，少用 #define 预处理指令"></a>多使用类型常量，少用 #define 预处理指令</h4><p>不要使用<code>#define</code>预处理指定定义常量，这样定义出来的类型不含类型信息。编译器只是会在编译器根据此执行查找与替换操作。即使有人重新定义了常量值，编译器也不警告。可以利用编译器特性来定义。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController</span><br><span class="line">static const NSTimeInterval kAnimationDuration = 0.3;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>在实现文件中使用<code>static const</code>来定义”只在编译单元内可见的常量”（每个.m为一个编译单元），此类常量不在全局符号表当中，所以无需加前缀。</p>
<p>在头文件中使用<code>extern</code>来声明全局变量，这种常量出现在全局符号表当中。所以其名称应该加以区分，通常用类名作为前缀：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extern NSString *const EOCLoginManagerDidLoginNotification;</span><br><span class="line"></span><br><span class="line">NSString *const EOCLoginManagerDidLoginNotification = @&quot;EOCLoginManagerDidLoginNotification&quot;;</span><br></pre></td></tr></table></figure>
<h4 id="用枚举表示状态、选项、状态码"><a href="#用枚举表示状态、选项、状态码" class="headerlink" title="用枚举表示状态、选项、状态码"></a>用枚举表示状态、选项、状态码</h4><p>使用 enum 的时候需要注意，应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这个值起个通俗易懂的名字。</p>
<p>如果把传递给某个方法的选项表示为枚举类型，而多个选项可同时使用，那么将各个选项定义为2的幂，以便通过<code>按位或操作</code>将其组合起来。<br>在使用 <code>NS_ENUM</code> 和 <code>NS_OPTHONS</code> 宏来定义枚举类型，要指名其数据类型，这样做可以确保枚举是用开发者所选的数据类型实现出来的，而不会采用编译器所选的类型。<code>NS_ENUM</code> 、<code>NS_OPTHONS</code> 其实内部做了这样一件事情：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter1-02.png" alt=""></p>
<p>其实就是判断编译器是否支持新式枚举，编译器按 C++ 模式编译，那么<code>enum</code>定义枚举的时候，其展开方式与<code>NS_ENUM</code>相同。枚举值使用<code>按位或运算</code>来组合的时候，C++ 认为运算结果的数据类型应该是枚举的底层类型，也就是<code>NSUInteger</code>，C++ 不允许将这个底层类型进行隐式转换，其展开方式为<code>NS_OPTHONS</code>。鉴于此，凡是需要<code>按位或</code>操作来组合的枚举都应该使用<code>NS_OPTHONS</code>来定义。若是枚举不需要互相组合，则应使用<code>NS_ENUM</code>来定义。通常我们会这样使用：</p>
<p><img src="/image/Effective-Objective-C-2.0-cahpter1-03.png" alt=""></p>
<p>在处理<code>switch</code>语句中，不要实现<code>default</code> 分支。在枚举值改变后，编译器就会提醒开发者：<code>switch</code>语句并未处理所有枚举。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/17/ ”∆µH-264—πÀı∏Ò Ω/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JY's Den">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/17/ ”∆µH-264—πÀı∏Ò Ω/" itemprop="url">视频H.264压缩格式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-17T23:31:31+08:00">
                2017-03-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>摄像头采集到的原始数据，需要将图片进行压缩处理，而 H.264恰好保证了良好的压缩</p>
<p>压缩算法只压缩图像改变的部分（需要找到上一帧和下一帧的区别）。</p>
<p>软编码：ffmpeg编码，进行 h.264编码后进行传输。<br>h.264分为 I、P、B帧</p>
<p>RTMP\RTSP当中依然包含 h.264 数据</p>
<p>摄像头采集到的是 RGBA 数据，需要将数据进行编码为 H.264 的流（encode，这里面可以通过硬件编码或者软件编码，就变得很小，适合进行网络传输）</p>
<p>收到网络传输的 h.264 数据，需要还原成一帧一帧的图片，这个过程叫做 decode（硬件解码（VideoToolBox）、软件解码（FFMpeg））。</p>
<p>将解码后的 h.264 数据（解码之后就成为 YUV 数据），交给硬件去播放。</p>
<p>音频：采集(PCM，无损压缩格式) -&gt; 编码(压缩算法：g711(打电话)，adpcm，aac(进行网络传输)) -&gt; 解码 -&gt; 将解码 pcm 交给硬件进行播放<br>使用 AudioQueue、openAL 进行播放视频</p>
<p>OpenCL：进行并行计算、深度学习等<br>OpenGL：3D、2D 游戏</p>
<p>码率：<br>采样率：设备在1秒钟对音频或者视频的采样次数。</p>
<h4 id="H264编码原理：I-B-P"><a href="#H264编码原理：I-B-P" class="headerlink" title="H264编码原理：I/B/P"></a>H264编码原理：I/B/P</h4><p>I 帧：帧内编码帧，I 帧表示关键帧，可以理解为这一帧画面的完整保留<br>解码时使用本帧数据就可以完成。解码时 I 帧就可以完全还原图像<br>P 帧：是 I 帧的参考帧，是 I 帧后面间隔1~2秒后的参考帧，也是 B 帧的参考帧<br>B 帧：双向差别帧，需要前面的 I 帧和后面的 P 帧进行压缩</p>
<h4 id="H264-NAL-头文件解析（重要）"><a href="#H264-NAL-头文件解析（重要）" class="headerlink" title="H264 NAL 头文件解析（重要）"></a>H264 NAL 头文件解析（重要）</h4><h4 id="PCM-gt-aac-编码规则"><a href="#PCM-gt-aac-编码规则" class="headerlink" title="PCM -&gt; aac 编码规则"></a>PCM -&gt; aac 编码规则</h4><p>在实际的音频编码中，假设网络每次接收到的音频数据为1280，<br>而在编码中我们设定输入的 PCM 数据为1024，实际的输出为768<br>那么如果输入的 PCM 数据小于实际接收到的音频数据，那么下次的数据<br>就会从下一帧中开始截取对应长度的音频，凑够1024长度的数据量。来进行编码<br>参考图片：PCM编码为 aac 规则</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/14/Swift÷–◊‘∂Ø“˝”√º∆ ˝/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JY's Den">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/14/Swift÷–◊‘∂Ø“˝”√º∆ ˝/" itemprop="url">Swift中自动引用计数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-14T14:11:01+08:00">
                2017-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Swift 使用自动引用计数来管理内存，当每次创建一个新的类的实例的时候，ARC 会分配一块内存来存储该实例信息。内存中会包含实例的类型信息，以及这个实例所有相关的存储类型属性的值。看一个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  let name: String</span><br><span class="line">  init(name: String) &#123;</span><br><span class="line">    self.name = name</span><br><span class="line">    print(&quot;\(name) is being initialized&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  deinit &#123;</span><br><span class="line">    print(&quot;\(name) is being deinitialized&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可选类型被自动初始化为 nil</span><br><span class="line">var reference1: Person?</span><br><span class="line">var reference2: Person?</span><br><span class="line">var reference3: Person?</span><br><span class="line"></span><br><span class="line">// John Appleseed is being initialized</span><br><span class="line">// 此时 Person 的引用计数为 3</span><br><span class="line">reference1 = Person(name: &quot;John Appleseed&quot;)</span><br><span class="line">reference2 = reference1</span><br><span class="line">reference3 = reference1</span><br><span class="line"></span><br><span class="line">reference1 = nil</span><br><span class="line">reference2 = nil</span><br><span class="line">// 当最后一个强引用的被断开时，ARC 会销毁它</span><br><span class="line">// John Appleseed is being deinitialized</span><br><span class="line">reference3 = nil</span><br></pre></td></tr></table></figure>
<p>如果出现两个类实例之间的循环强引用，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  let name: String</span><br><span class="line">  init(name: String) &#123; self.name = name &#125;</span><br><span class="line">  var apartment: Apartment?</span><br><span class="line">  deinit &#123; print(&quot;\(name) is being deinitialized&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Apartment &#123;</span><br><span class="line">  let unit: String</span><br><span class="line">  init(unit: String) &#123; self.unit = unit &#125;</span><br><span class="line">  var tenant: Person?</span><br><span class="line">  deinit &#123; print(&quot;Apartment \(unit) is being deinitialized&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 两个可选的变量，并初始化为 nil</span><br><span class="line">var john: Person?</span><br><span class="line">var unit4A: Apartment?</span><br><span class="line"></span><br><span class="line">// 创建实例</span><br><span class="line">john = Person(name: &quot;John Appleseed&quot;)</span><br><span class="line">unit4A = Apartment(unit: &quot;4A&quot;)</span><br><span class="line"></span><br><span class="line">// 将两个实例进行关联，这样就出现了强引用</span><br><span class="line">john!.apartment = unit4A</span><br><span class="line">unit4A!.tenant = john</span><br><span class="line"></span><br><span class="line">// 即使断开两个变量的引用，引用计数也并不会为 0，实例也不会被销毁。造成内存泄露</span><br><span class="line">john = nil</span><br><span class="line">unit4A = nil</span><br></pre></td></tr></table></figure>
<p>Swift 提供两种方式来解决实例间的强引用：<code>弱引用</code>和<code>无主引用</code>。它们都允许循环引用中的一个实例引用另外一个实例不保持强引用。这样就相互引用就不会产生循环强引用。</p>
<h3 id="弱引用（weak）"><a href="#弱引用（weak）" class="headerlink" title="弱引用（weak）"></a>弱引用（weak）</h3><p><code>弱引用</code>：不会对其引用的实例保持强引用，这样就组织了引用变为循环强引用。在声明属性或者变量时，在前面加上<code>weak</code>关键字表明这是一个弱引用。因为弱引用不会保持所引用的实例，即使引用存在，实例也有可能被销毁。因此，ARC 会在引用的实例被销毁后自动将其赋值为 nil 。并且因为弱引用可以允许它们的值在运行时被赋值为 nil ，所以<code>它们会被定义为可选类型 变量，而不是常量</code>。需要注意的是：<code>当 ARC 设置弱引用为 nil 时，属性观察不会被触发。</code></p>
<p>将上面<code>Apartment</code>类中的<code>tenant</code>属性前面使用<code>weak</code>来修饰，像这样：<code>weak var tenant: Person?</code>，就会打破循环强引用。</p>
<h3 id="无主引用（unowned）"><a href="#无主引用（unowned）" class="headerlink" title="无主引用（unowned）"></a>无主引用（<code>unowned</code>）</h3><p><code>无主引用</code>：和弱引用类似，无主引用不会牢牢保持住引用的实例。<code>和弱引用不同的是，无主引用在其他实例有相同或者更长的生命周期时使用</code>。你可以在声明属性或者变量时，在前面加上关键字 <code>unowned</code> 表示这是一个无主引用。无主引用通常都被期望拥有值。不过 ARC 无法在实例被销毁后将无主引用设为 nil ，因为非可选类型的变量不允许被赋值为 nil 。</p>
<p><code>注意</code>：在使用无主引用时，必须确保引用始终指向一个未销毁的实例。如果视图在实例销毁后，访问实例的无主引用，会触发运行时错误。</p>
<p>举个例子，个客户可能有或者没有信用卡，但是一张信用卡总是关联着一个客户。下面表示这种关系，<code>Customer</code> 类有 一个可选类型的 <code>card</code> 属性，但是 <code>CreditCard</code> 类有一个非可选类型的 <code>customer</code> 属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">class Customer &#123;</span><br><span class="line">  let name: String</span><br><span class="line">  var card: CreditCard?</span><br><span class="line">  init(name: String) &#123;</span><br><span class="line">    self.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  deinit &#123; print(&quot;\(name) is being deinitialized&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CreditCard &#123;</span><br><span class="line">  let number: UInt64</span><br><span class="line">  // 这里的属性 customer 不允许被赋值为 nil</span><br><span class="line">  unowned let customer: Customer</span><br><span class="line">  init(number: UInt64, customer: Customer) &#123;</span><br><span class="line">    self.number = number</span><br><span class="line">    self.customer = customer</span><br><span class="line">  &#125;</span><br><span class="line">  deinit &#123; print(&quot;Card #\(number) is being deinitialized&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var john: Customer?</span><br><span class="line">john = Customer(name: &quot;John Appleseed&quot;)</span><br><span class="line">john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)</span><br><span class="line"></span><br><span class="line">john = nil</span><br><span class="line">// 由于 customer 为 unowned，当断开 john 变量持有的强引用，再也没有指向 Customer 实例的强引用了</span><br><span class="line">// John Appleseed is being deinitialized</span><br><span class="line">// Card #1234567890123456 is being deinitialized</span><br></pre></td></tr></table></figure>
<p><code>注意</code>：上面的例子展示了如何使用安全的无主引用。对于需要禁用运行时的安全检查的情况(例如，出于性能方面的原因)，Swift还提供了不安全的无主引用。与所有不安全的操作一样，你需要负责检查代码以确保其安全性。你 可以通过 unowned(unsafe) 来声明不安全无主引用。如果你试图在实例被销毁后，访问该实例的不安全无主引 用，你的程序会尝试访问该实例之前所在的内存地址，这是一个不安全的操作。</p>
<p>那么什么时候使用 weak 或者 unowned 呢？</p>
<p>当其他的实例有更短的生命周期时，使用弱引用，也就是说，当其他实例析构在先时。在上面公寓的例子中，很显然一个公寓在它的生命周期内会在某个时间段没有它的主人，所以一个弱引用就加在公寓类里面，避免循环引用。相比之下，当其他实例有相同的或者更长生命周期时，请使用无主引用。也就是：</p>
<p>Person 和 Apartment 的例子展示了两个属性的值都允许为 nil ，并会潜在的产生循环强引用。这种场景最适合用 弱引用来解决。<br>å<br>Customer 和 CreditCard 的例子展示了一个属性的值允许为 nil ，而另一个属性的值不允许为 nil ，这也可能会 产生循环强引用。这种场景最适合通过无主引用来解决。</p>
<h3 id="无主引用以及隐式解析可选属性"><a href="#无主引用以及隐式解析可选属性" class="headerlink" title="无主引用以及隐式解析可选属性"></a>无主引用以及隐式解析可选属性</h3><p>当两个属性都必须有值，并且初始化完成后永远不会为 nil 。在这种场 景中，需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。这使两个属性在初始化完成后能被直接访问(不需要可选展开)，同时避免了循环引用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">  <span class="comment">// 注意这里：将 Country 的 capitalCity 属性声明为隐式解析可选类型的属性。这意味着像其他可选类型一样， capitalCity 属性的默认值为 nil ，但是不需要展开它的值就能访问它。</span></span><br><span class="line">  <span class="keyword">var</span> capitalCity: <span class="type">City</span>!</span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, capitalName: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.capitalCity = <span class="type">City</span>(name: capitalName, country: <span class="keyword">self</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">City</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">unowned</span> <span class="keyword">let</span> country: <span class="type">Country</span></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, country: <span class="type">Country</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.country = country</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Country 的实例在给构造函数中给 name 属性赋完值后，整个初始化过程就完成了。 同时将 self 作为参数传递给  City 的构造函数</span></span><br><span class="line"><span class="comment">// capitalCity 属性能够被直接访问，不需要通过感叹号来展开它的可选值。</span></span><br><span class="line"><span class="keyword">var</span> country = <span class="type">Country</span>(name: <span class="string">"Canada"</span>, capitalName: <span class="string">"Ottawa"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(country.name)</span>'s capital city is called <span class="subst">\(country.capitalCity.name)</span>"</span>)</span><br><span class="line"><span class="comment">// Canada's capital city is called Ottawa</span></span><br></pre></td></tr></table></figure>
<h3 id="闭包引起的循环强引用"><a href="#闭包引起的循环强引用" class="headerlink" title="闭包引起的循环强引用"></a>闭包引起的循环强引用</h3><p>通过<code>捕获值列表</code>作为闭包的一部分，通过这种方式可以解决闭包和类实例之间的循环强引用。捕获列表定义了闭包体内捕获一个或者多个引用类型的规则。跟解决两个类实例间的循环强引用一样，声明每个捕获的引用为弱引用或无主引用，而不是强引用。应当根据代码关系来决定使用弱引用还是无主引用。下面看一个例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> text: <span class="type">String</span>?</span><br><span class="line">  <span class="comment">// 闭包当中使用了 self，它捕获了 HTMLElement 的实例 text，并对 self 强引用</span></span><br><span class="line">  <span class="comment">// 虽然闭包多次使用 self，它只捕获 HTMLElement 实例的一个强引用</span></span><br><span class="line">  <span class="built_in">lazy</span> <span class="keyword">var</span> asHTML: (<span class="type">Void</span>) -&gt; <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> text = <span class="keyword">self</span>.text &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;<span class="subst">\(text)</span>&lt;/<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;"</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span> /&gt;"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, text: <span class="type">String</span>? = <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.text = text</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> heading = <span class="type">HTMLElement</span>(name: <span class="string">"h1"</span>)</span><br><span class="line"><span class="keyword">let</span> defaultText = <span class="string">"some default text"</span></span><br><span class="line">heading.asHTML = &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(heading.name)</span>&gt;<span class="subst">\(heading.text ?? defaultText)</span>&lt;/<span class="subst">\(heading.name)</span>&gt;"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(heading.asHTML())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例的 asHTML 属性持有闭包的强引用，此时在闭包内部，闭包又强引用 self。造成循环强引用</span></span><br><span class="line"><span class="keyword">var</span> paragraph: <span class="type">HTMLElement</span>? = <span class="type">HTMLElement</span>(name: <span class="string">"p"</span>, text: <span class="string">"hello, world"</span>)</span><br><span class="line"><span class="built_in">print</span>(paragraph!.asHTML())</span><br></pre></td></tr></table></figure>
<p><code>注意</code>：只要在闭包内使用 self 的成员，就要用 <code>self.someProperty</code> 或者 <code>self.someMethod()</code> (而 不只是 someProperty 或 someMethod() )。这提醒你可能会一不小心就捕获了 self 。</p>
<h3 id="解决闭包引起的强引用"><a href="#解决闭包引起的强引用" class="headerlink" title="解决闭包引起的强引用"></a>解决闭包引起的强引用</h3><p>如果闭包有参数列表和返回类型，把捕获值列表放在它们的前面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lazy var someClosure: (Int, String) -&gt; String = &#123;</span><br><span class="line">  [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in</span><br><span class="line">  // 这里是闭包的函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果闭包没有指明参数列表或者返回类型，即它们会通过上下文推断，那么可以把捕获列表和关键字 in 放在闭包 最开始的地方:</span><br><span class="line">lazy var someClosure: Void -&gt; String = &#123;</span><br><span class="line">  [unowned self, weak delegate = self.delegate!] in</span><br><span class="line">  // 这里是闭包的函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果闭包和捕获的实例总是相互引用并同时销毁的时候，将闭包内的捕获定义为<code>无主引用</code>。相反，如果被捕获的引用可能会变为 <code>nil</code>时，将闭包内的捕获定义为<code>弱引用</code>。弱引用总是可选类型，并且当引用 的实例被销毁后，弱引用的值会自动置为 nil 。这使我们可以在闭包体内检查它们是否存在。</p>
<p><code>注意</code>：如果被捕获的引用绝对不会变为 nil ，应该用无主引用，而不是弱引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class HTMLElement &#123;</span><br><span class="line">  let name: String</span><br><span class="line">  let text: String?</span><br><span class="line">  lazy var asHTML: (Void) -&gt; String = &#123;</span><br><span class="line">    // 捕获值列表是 [unowned self]，表示将 self 捕获为无主引用而不是强引用。</span><br><span class="line">    // 实例被销毁，最终会看到析构函数被调用</span><br><span class="line">    [unowned self] in</span><br><span class="line">    if let text = self.text &#123;</span><br><span class="line">      return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return &quot;&lt;\(self.name) /&gt;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  init(name: String, text: String? = nil) &#123;</span><br><span class="line">    self.name = name</span><br><span class="line">    self.text = text</span><br><span class="line">  &#125;</span><br><span class="line">  deinit &#123;</span><br><span class="line">    print(&quot;\(name) is being deinitialized&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/10/Swift÷–µƒ±’∞¸/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JY's Den">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/10/Swift÷–µƒ±’∞¸/" itemprop="url">Swift中的闭包总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-10T11:33:39+08:00">
                2017-03-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>闭包是自包含的函数代码块，Swift 中的闭包与 C 和 Objective-C 中的代码块(b<br>locks)以及其他一些编程语言中的匿名函数比较相似。Swift 会为你管理在捕获过程中涉及到的所有内存操作。</p>
<p>闭包表达式的语法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; (parameters) -&gt; returnType <span class="keyword">in</span></span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>闭包表达式参数 可以是 in-out 参数，但不能设定默认值。也可以使用具名的可变参数。闭包的函数体部分由关键字 <code>in</code> 引入，表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。</p>
<p>举个例子，<code>sorted(by:)</code>方法接收一个闭包，接收两个参数，返回一个 Bool 值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">"Chris"</span>, <span class="string">"Alex"</span>, <span class="string">"Ewa"</span>, <span class="string">"Barry"</span>, <span class="string">"Daniella"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> reversedNames = names.sorted(by: &#123; (s1: <span class="type">String</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> s1 &gt; s2</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// reversedNames 为 ["Ewa", "Daniella", "Chris", "Barry", "Alex"]</span></span><br></pre></td></tr></table></figure>
<p>上面的闭包函数体也可以改写成一行代码，一对圆括号仍然包裹住了方法的整个参数。然而，参数现在变成了<code>内联闭包</code>。：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &#123; (s1: <span class="type">String</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span> <span class="keyword">return</span> s1 &gt; s2 &#125; )</span><br></pre></td></tr></table></figure>
<p>由于 Swift 可以推断其参数和返回值类型，所以其参数<code>(String, String) -&gt; Bool</code>类型的函数并不需要作为闭包表达式定义的一部分。因为所有类型都可以被推断，所以<code>-&gt;</code>和围绕在参数周围的括号也可以被省略：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &#123; s1, s2 <span class="keyword">in</span> <span class="keyword">return</span> s1 &gt; s2 &#125; )</span><br></pre></td></tr></table></figure>
<p><code>单表达式闭包</code>(这里闭包函数体只包含了一个单一表达式( s1 &gt; s2 ))可以通过省略<code>return</code>关键字来隐式返回单行表达式的结果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &#123; s1, s2 <span class="keyword">in</span> s1 &gt; s2 &#125; )</span><br></pre></td></tr></table></figure>
<p>Swift 为<code>内联闭包</code>提供<code>参数名称缩写功能</code>，你可以通过<code>$0</code>，<code>$1</code>，<code>$2</code>来顺序调用闭包的参数，以此类推。如果闭包表达式中使用参数名称缩写，也可以在闭包定义中省略参数列表，并且对应参数名称缩写的类型会通过函数类型进行推断。<code>in</code> 关键字也同样可以被省略，因为此时闭包表达式完全由闭包函数体构成（<code>$0</code>、<code>$1</code>分别表示闭包的第一个和第二个参数）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125; )</span><br></pre></td></tr></table></figure>
<p> <code>运算符方法</code>：<code>String</code>类型定义了关于<code>&gt;</code>的字符串实现，其作为一个函数接受两个<code>String</code>类型的参数并返回<code>Bool</code>类型。这恰好与<code>sorted(by:)</code>方法的参数需要函数类型相符合。所以可以自动推断出<code>&gt;</code>的字符串函数实现。</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &gt;)</span><br></pre></td></tr></table></figure>
<h3 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h3><p>如果你需要将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用尾随闭包来增强函数的可读性。<code>尾随闭包是一个书写在函数括号之后的闭包表达式函数支持将其作为最后一个参数调用</code>。在使用尾随闭包时，你不用写出它的参数标签：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionThatTakesAClosure</span><span class="params">(closure: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  <span class="comment">// 函数体部分</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以下是不使用尾随闭包进行函数调用</span></span><br><span class="line">someFunctionThatTakesAClosure(closure: &#123;</span><br><span class="line">  <span class="comment">// 闭包主体部分</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 以下是使用尾随闭包进行函数调用</span></span><br><span class="line">someFunctionThatTakesAClosure() &#123;</span><br><span class="line">  <span class="comment">// 闭包主体部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子可改写为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted() &#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>
<p><code>如果闭包表达式是函数或方法的唯一参数，可以省略（）</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted &#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h3><p>闭包可以在其被定义的上下文中捕获常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeIncrementer</span><span class="params">(forIncrement amount: Int)</span></span> -&gt; () -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> runningTotal = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">incrementer</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        runningTotal += amount</span><br><span class="line">        <span class="keyword">return</span> runningTotal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incrementer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无论你是将函数或闭包赋值给一个常量还是变量，实际上都是将常量或者变量的值设置为对应行数或者闭包的引用</span></span><br><span class="line"><span class="keyword">let</span> incrementByTen = makeIncrementor(forIncrement: <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>闭包捕获了<code>amount</code>、<code>runningTotal</code>两个变量的引用，捕获引用保证了 <code>runningTotal</code> 和 <code>amount</code> 变量在调用完 <code>makeIncrementer</code> 后不会消失，并且保证了在下一次执行 <code>incrementer</code> 函数时，<code>runningTotal</code> 依旧存在。Swift 负责被捕获变量的所有内存管理工作，包括释放不再需要的变量。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">incrementByTen() <span class="comment">// 10</span></span><br><span class="line">incrementByTen() <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p><code>注意：</code>如果你将闭包赋值给一个类实例的属性，并且该闭包通过访问该实例或其成员而捕获了该实例，你将在闭包和该 实例间创建一个循环强引用</p>
<h3 id="逃逸闭包"><a href="#逃逸闭包" class="headerlink" title="逃逸闭包"></a>逃逸闭包</h3><p><code>逃逸闭包</code>：当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中逃逸。可以在参数名之前标注<code>@escaping</code>，来指明这个闭包时允许“逃逸”出这个函数的。</p>
<p>一种能使闭包“逃逸”出函数的方法是，<code>将这个闭包保存在一个函数外部定义的变量中</code>。比如常用的回调函数，这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。在这种情况下，闭包需要“逃逸”出函数，因为闭包需要在函数返回之后被调用。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// someFunctionWithEscapingClosure(_:)中的闭包是一个逃逸闭包，该闭包被添加到一个函数外定义的数组中。如果不显示将参数标记为 @escaping ，会得到编译错误</span></span><br><span class="line"><span class="keyword">var</span> completionHandlers: [() -&gt; <span class="type">Void</span>] = []</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionWithEscapingClosure</span><span class="params">(completionHandler: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  completionHandlers.append(completionHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>注意</code>：标记为<code>@escaping</code>的闭包必须在闭包中显式的引用<code>self</code>，而非逃逸闭包，它可以隐式的引用<code>self</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionWithNonescapingClosure</span><span class="params">(closure: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  closure()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">    someFunctionWithEscapingClosure &#123; <span class="keyword">self</span>.x = <span class="number">100</span> &#125;</span><br><span class="line">    someFunctionWithNonescapingClosure &#123; x = <span class="number">200</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="type">SomeClass</span>()</span><br><span class="line">instance.doSomething()</span><br><span class="line"><span class="built_in">print</span>(instance.x) <span class="comment">// 200</span></span><br><span class="line"></span><br><span class="line">completionHandlers.first?()</span><br><span class="line"><span class="built_in">print</span>(instance.x) <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<h3 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h3><p><code>自动闭包</code>是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。这种闭包不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值这种便利语法让你能够省略闭包的花括号，用一个普通的表达式来代替显式的闭包。</p>
<p>自动闭包能够延延迟求职，因为知道你调用这个闭包，代码段才会被执行。延迟求值对于高计算成本的代码来说很有用。举个例子表示如何延时求值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> customersInLine = [<span class="string">"Chris"</span>, <span class="string">"Alex"</span>, <span class="string">"Ewa"</span>, <span class="string">"Barry"</span>, <span class="string">"Daniella"</span>]</span><br><span class="line"><span class="built_in">print</span>(customersInLine.<span class="built_in">count</span>) <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// customerProvider 的类型不是 String，而是 () -&gt; String</span></span><br><span class="line"><span class="keyword">let</span> customerProvider = &#123; customersInLine.remove(at: <span class="number">0</span>) &#125;</span><br><span class="line"><span class="built_in">print</span>(customersInLine.<span class="built_in">count</span>) <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Now serving <span class="subst">\(customerProvider()</span>)!"</span>) <span class="comment">// "Now serving Chris!"</span></span><br><span class="line"><span class="built_in">print</span>(customersInLine.<span class="built_in">count</span>) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>将闭包作为参数传递给函数时，同样能获取延时求值行为。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> customersInLine = [<span class="string">"Alex"</span>, <span class="string">"Ewa"</span>, <span class="string">"Barry"</span>, <span class="string">"Daniella"</span>]</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(customer customerProvider: <span class="params">()</span></span></span> -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Now serving <span class="subst">\(customerProvider()</span>)!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">serve(customer: &#123; customersInLine.remove(at: <span class="number">0</span>) &#125; ) <span class="comment">// Now serving Alex!</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(customersInLine) <span class="comment">// ["Ewa", "Barry", "Daniella"]</span></span><br></pre></td></tr></table></figure>
<p>也可以将参数标记为 <code>@autoclosure</code> 来接收一个自动闭包。现在可以将该函数当做接受<code>String</code>类型参数（而非闭包）的函数来调用。<code>customerProvider</code>参数将自动转化为一个闭包，因为该参数被标记了<code>@autoclosure</code>特性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> customersInLine = [<span class="string">"Alex"</span>, <span class="string">"Ewa"</span>, <span class="string">"Barry"</span>, <span class="string">"Daniella"</span>]</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(customer customerProvider: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Now serving <span class="subst">\(customerProvider()</span>)!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">serve(customer: customersInLine.remove(at: <span class="number">0</span>)) <span class="comment">// Now serving Alex!</span></span><br><span class="line"><span class="built_in">print</span>(customersInLine) <span class="comment">// ["Ewa", "Barry", "Daniella"]</span></span><br></pre></td></tr></table></figure>
<p>如果想让一个闭包自动“逃逸”，则应该同时使用<code>@autoclosure</code>和<code>@escaping</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> customersInLine = [<span class="string">"Alex"</span>, <span class="string">"Ewa"</span>, <span class="string">"Barry"</span>, <span class="string">"Daniella"</span>]</span><br><span class="line"><span class="keyword">var</span> customerProviders: [() -&gt; <span class="type">String</span>] = []</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectCustomerProviders</span><span class="params">(<span class="number">_</span> customerProvider: @autoclosure @escaping <span class="params">()</span></span></span> -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">  customerProviders.append(customerProvider)</span><br><span class="line">&#125;</span><br><span class="line">collectCustomerProviders(customersInLine.remove(at: <span class="number">0</span>))</span><br><span class="line">collectCustomerProviders(customersInLine.remove(at: <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Collected <span class="subst">\(customerProviders.<span class="built_in">count</span>)</span> closures."</span>) <span class="comment">// Collected 2 closures.</span></span><br><span class="line"><span class="keyword">for</span> customerProvider <span class="keyword">in</span> customerProviders &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Now serving <span class="subst">\(customerProvider()</span>)!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Now serving Alex!</span></span><br><span class="line"><span class="comment">// Now serving Ewa!</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(customersInLine) <span class="comment">// ["Barry", "Daniella"]</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/12/Founctors”ÎMonad/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JY's Den">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/12/Founctors”ÎMonad/" itemprop="url">Founctors与Monad</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-12T10:23:31+08:00">
                2017-02-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Founctor（函子）"><a href="#Founctor（函子）" class="headerlink" title="Founctor（函子）"></a>Founctor（函子）</h3><p>函子包含以下定义：</p>
<ul>
<li>包装了另一种类型，就像 <code>Array&lt;T&gt;</code>、<code>Optional&lt;T&gt;</code>，它们都包装了 <code>T</code> 类型。</li>
<li>有一个函数签名为 <code>(T-&gt;U) -&gt; Type&lt;U&gt;</code> 的 <code>map</code> 方法。</li>
</ul>
<h3 id="Monad（单子）"><a href="#Monad（单子）" class="headerlink" title="Monad（单子）"></a>Monad（单子）</h3><ul>
<li>是一个函子（包含了内部类型 <code>T</code> 并且拥有 <code>map</code> 方法）。</li>
<li>同时有函数签名为 <code>(T -&gt; Type&lt;U&gt;) -&gt; Type&lt;U&gt;</code> 的 <code>flatMap</code> 方法。</li>
</ul>
<p><a href="http://swift.gg/2015/10/30/lets-talk-about-monads/" target="_blank" rel="noopener">http://swift.gg/2015/10/30/lets-talk-about-monads/</a></p>
<hr>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><img src="http://alisoftware.github.io/swift/2015/10/17/lets-talk-about-monads/" alt="Let&#39;s talk about Monads"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/10/Swift-Equatable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JY's Den">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/10/Swift-Equatable/" itemprop="url">Swift Equatable</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-10T23:22:17+08:00">
                2017-02-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>判断两个实例的值、或者实例是否相等，必须遵循 <code>Equatable</code> 协议</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerRef</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">init</span>(<span class="number">_</span> value: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: IntegerRef, rhs: IntegerRef)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.value == rhs.value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="type">IntegerRef</span>(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">let</span> b = <span class="type">IntegerRef</span>(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a == a, a == b, separator: <span class="string">", "</span>)</span><br><span class="line"><span class="comment">// Prints "true, true"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a</span><br><span class="line"><span class="built_in">print</span>(a === <span class="built_in">c</span>, b === <span class="built_in">c</span>, separator: <span class="string">", "</span>)</span><br><span class="line"><span class="comment">// Prints "true, false"</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/10/Swift-NSCopying/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JY's Den">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/10/Swift-NSCopying/" itemprop="url">Swift-NSCopying</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-10T20:24:55+08:00">
                2017-02-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>自定义类想要支持拷贝，必须遵循 <code>NSCopying</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>: <span class="title">NSCopying</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="comment">// required 只能修饰类初始化方法，当子类初始化方法与父类的不同，子类必须实现初始化方法，并且要使用 required 而不是 overide</span></span><br><span class="line">  <span class="keyword">required</span> <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">copy</span><span class="params">(with zone: NSZone? = <span class="literal">nil</span>)</span></span> -&gt; <span class="type">Any</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> student = <span class="type">Student</span>(name: <span class="keyword">self</span>.name)</span><br><span class="line">    <span class="keyword">return</span> student</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu1 = <span class="type">Student</span>(name: <span class="string">"JY"</span>)</span><br><span class="line"><span class="keyword">let</span> stu2 = stu1.copy() <span class="keyword">as</span>! <span class="type">Student</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="type">ObjectIdentifier</span>(stu1) == <span class="type">ObjectIdentifier</span>(stu2)</span><br><span class="line">stu2.name = <span class="string">"YU"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JY</span></span><br><span class="line">stu1.name</span><br><span class="line"><span class="comment">// YU</span></span><br><span class="line">stu2.name</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/10/Swift-AnyClass/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JY's Den">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/10/Swift-AnyClass/" itemprop="url">Swift AnyClass</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-10T19:42:15+08:00">
                2017-02-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>AnyClass</code>：是所有类都隐式遵循的协议，当你用<code>AnyClass</code>作为实例的具体类型，所有已知的<code>@objc</code>类的方法和属性都作为隐式解包的可选方法或者属性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">  <span class="meta">@objc</span> <span class="keyword">static</span> <span class="keyword">let</span> describe = <span class="string">"class description"</span></span><br><span class="line">  <span class="meta">@objc</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">getDefaultValue</span>() -&gt; <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDefaultValue</span><span class="params">(<span class="number">_</span> <span class="built_in">c</span>: AnyClass)</span></span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">c</span>.getDefaultValue?()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDescribeValue</span><span class="params">(<span class="number">_</span> <span class="built_in">c</span>: AnyClass)</span></span> -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">c</span>.describe</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ptional(100)</span></span><br><span class="line"><span class="built_in">print</span>(getDefaultValue(<span class="type">Student</span>.<span class="keyword">self</span>))</span><br><span class="line"><span class="comment">// Optional("class description")</span></span><br><span class="line"><span class="built_in">print</span>(getDescribeValue(<span class="type">Student</span>.<span class="keyword">self</span>))</span><br></pre></td></tr></table></figure>
<p>还可以作为类型检测：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeDelegate</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>: <span class="title">SomeDelegate</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="type">SomeClass</span>.<span class="keyword">self</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSomeDelegate</span><span class="params">(<span class="number">_</span> type: AnyClass)</span></span> -&gt; <span class="type">Bool</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> type <span class="keyword">is</span> <span class="type">SomeDelegate</span>.<span class="type">Type</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">print</span>(isSomeDelegate(instance))</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">JY</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">46</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/devyu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JY</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
